[ { "title": "Effect Systems", "url": "/posts/effect-systems/", "categories": "Programming", "tags": "haskell, functional, programming", "date": "2022-03-21 00:00:00 -0400", "snippet": "As I’ve begun exploring the world of so-called algebraic effect systems,I’ve become increasingly frustrated in the level of documentation around them.Learning to use them (and moreso understanding how they work) requires divinginto library internals, watching various videos, and hoping to grok why certaineffects aren’t being interpreted the way you might have hoped. My goal in thispost is to address this issue, at least to some degree, in a focused,pedagogical fashion.A large portion of this post has been derived from the implementation of thefused-effects library,chosen because it seems to have the most active development, the smallestdependency footprint, and minimal type machinery. In turn, this library waslargely inspired by Nicolas Wu, Tom Schrijvers, and Ralf Hinze’s work inEffect Handlers in Scope.As such, we’ll discuss choice parts of this paper as well.Code snippets can be found in this git repository. Free Monads Making a Monad Making an Applicative Algebraic Data Types Composing Effects Sum Types Membership Higher-Order Effects Scoping Problems A Stronger Free Higher-Order Syntax Higher-Order Semantics Lifting Limitations ConclusionFree MonadsTo begin our exploration, let’s pose a few questions: How can we go about converting a simple algebraic data type into a monad? Does there exist some set of minimal requirements the data type must fulfillto make this conversion “free”?1To help guide our decision making, we’ll examine the internals of some arbitrarymonad. More concretely, let’s see what 1 + 2 could look like within a monadiccontext:onePlusTwo :: forall m. Monad m =&amp;gt; m IntonePlusTwo = do a &amp;lt;- pure 1 b &amp;lt;- pure 2 pure $ a + bThe above won’t win any awards, but it should be illustrative enough for ourpurposes. do is just syntactic sugar for repeated bind applications (&amp;gt;&amp;gt;=),so we could’ve written the above alternatively as:onePlusTwo&#39; :: forall m. Monad m =&amp;gt; m IntonePlusTwo&#39; = pure 1 &amp;gt;&amp;gt;= (\\a -&amp;gt; pure 2 &amp;gt;&amp;gt;= (\\b -&amp;gt; pure (a + b)))This is where we’ll pause for a moment and squint. We see that do syntaxdesugars into something that looks awfully close to a (non-empty) list! Let’scompare the above with how we might define that:data NonEmptyList a = Last a | Cons a (a -&amp;gt; NonEmptyList a)onePlusTwo&#39;&#39; :: NonEmptyList IntonePlusTwo&#39;&#39; = Cons 1 (\\a -&amp;gt; Cons 2 (\\b -&amp;gt; Last (a + b)))runNonEmptyList :: NonEmptyList Int -&amp;gt; IntrunNonEmptyList (Last a) = arunNonEmptyList (Cons a f) = runNonEmptyList (f a)-- &amp;gt;&amp;gt;&amp;gt; runIdentity onePlusTwo&#39;-- 3-- &amp;gt;&amp;gt;&amp;gt; runNonEmptyList onePlusTwo&#39;&#39;-- 3Take a moment to appreciate the rough pseudo-equivalence of NonEmptyList and amonad. Also take a moment to appreciate the differences. Because we no longeremploy the bind operator anywhere within our function definitions, we haveeffectively separated the syntax of our original function from itssemantics. That is, onePlusTwo&#39;&#39; can be viewed as a program in and ofitself, and the runNonEmptyList handler can be viewed as theinterpretation of said program.Making a MonadNonEmptyList was formulated from a monad, so it’s natural to think perhaps ittoo is a monad. Unfortunately this is not the case - it isn’t even a functor!Give it a try or use {-# LANGUAGE DeriveFunctor #-} to ask the compiler tomake an attempt on your behalf. Tip Type variable a is said to be contravariant withrespect to Cons. That is, a resides in a negative positionwithin Cons’s function.If we can’t make this a monad as is, are there a minimal number of changes wecould introduce to make it happen? Ideally our changes maintain the “shape” ofthe data type as much as possible, thereby maintaining the integrity behind theoriginal derivation. Since our current roadblock stems from type variable a’sposition in Cons, let’s see what happens if we just abstract it away:data NonEmptyList&#39; f a = Last&#39; a | Cons&#39; a (f (NonEmptyList&#39; f a))With general parameter f now in the place of (-&amp;gt;) a, a functor derivationbecomes possible provided f is also a Functor:instance (Functor f) =&amp;gt; Functor (NonEmptyList&#39; f) where fmap f (Last&#39; a) = Last&#39; (fmap f a) fmap f (Cons&#39; a ts) = Cons&#39; (f a) (fmap (fmap f) g)And though we needed to modify our syntax and semantics slightly, the proposedchanges do not lose us out on anything of real consequence:twoPlusThree :: NonEmptyList&#39; (Reader Int) InttwoPlusThree = Cons&#39; 2 (reader (\\a -&amp;gt; Cons&#39; 3 (reader (\\b -&amp;gt; Last&#39; (a + b)))))runNonEmptyList&#39; :: NonEmptyList&#39; (Reader Int) Int -&amp;gt; IntrunNonEmptyList&#39; (Last&#39; a) = arunNonEmptyList&#39; (Cons&#39; a f) = runNonEmptyList&#39; (runReader f a)-- &amp;gt;&amp;gt;&amp;gt; runNonEmptyList&#39; twoPlusThree-- 5Compare the above snippet with onePlusTwo&#39;.The Applicative instance is slightly more involved so we’ll hold off on thatfront for the time-being. For the sake of forging ahead though, assume itexists. With the Functor instance established and the Applicative instanceassumed, we are ready to tackle writing the Monad instance. A first attemptwould probably look like the following:instance (Functor f) =&amp;gt; Monad (NonEmptyList&#39; f) where (&amp;gt;&amp;gt;=) :: NonEmptyList&#39; f a -&amp;gt; (a -&amp;gt; NonEmptyList&#39; f b) -&amp;gt; NonEmptyList&#39; f b Last&#39; a &amp;gt;&amp;gt;= g = g a Cons&#39; a f &amp;gt;&amp;gt;= g = Cons&#39; _ (fmap (&amp;gt;&amp;gt;= g) f)Defining bind (&amp;gt;&amp;gt;=) on Last&#39; is straightforward, but Cons&#39; again presentsa problem. With g serving as our only recourse of converting an a intoanything, how should we fill in the hole (_)? One approach could be:instance (Functor f) =&amp;gt; Monad (NonEmptyList&#39; f) where Cons&#39; a f &amp;gt;&amp;gt;= g = let ts = fmap (&amp;gt;&amp;gt;= g) f in case g a of Last&#39; b -&amp;gt; Cons&#39; b ts Cons&#39; b f&#39; -&amp;gt; Cons&#39; b (f&#39; &amp;lt;&amp;gt; ts)but this is pretty unsatisfactory. This definition requires a Semigroupconstraint on f, which in turn requires some lifting operator. After all, howelse could we append Last a1 &amp;lt;&amp;gt; Last a2 together? Suddenly the list ofconstraints on f is growing despite our best intentions. Let’s take a stepback and see if there is something else we can try.The insight falls from the one constraint we had already added (admittedlywithout much fanfare). That is, we are requiring type variable f to be aFunctor! With this in mind, we can actually massage our first parameter into abind-compatible one by simply omitting it altogether.To elaborate, it is well knownsimple algebraic data types are isomorphic to “primitive” functors (Identityand Const) and that (co)products of functors yield more functors. We cantherefore “absorb” the syntax of a into f by using a product type as acontainer of sorts:data NonEmptyList&#39;&#39; f a = Last&#39;&#39; a | Cons&#39;&#39; (f (NonEmptyList&#39;&#39; f a))data Container a m k = Container a (m k) deriving FunctorthreePlusFour :: NonEmptyList&#39;&#39; (Container Int (Reader Int)) IntthreePlusFour = Cons&#39;&#39; (Container 3 (reader (\\a -&amp;gt; Cons&#39;&#39; (Container 4 (reader (\\b -&amp;gt; Last&#39;&#39; (a + b)))))))runNonEmptyList&#39;&#39; :: NonEmptyList&#39;&#39; (Container Int (Reader Int)) Int -&amp;gt; IntrunNonEmptyList&#39;&#39; (Last&#39;&#39; a) = arunNonEmptyList&#39;&#39; (Cons&#39;&#39; (Container a f)) = runNonEmptyList&#39;&#39; (runReader f a)-- &amp;gt;&amp;gt;&amp;gt; runNonEmptyList&#39;&#39; threePlusFour-- 7The above demonstrates NonEmptyList&#39; was in fact overly specific for ourpurposes. By generalizing further still, we lose no expressivity and gain the capacity to finally write our Monad instance:instance (Functor f) =&amp;gt; Monad (NonEmptyList&#39;&#39; f) where Last&#39;&#39; a &amp;gt;&amp;gt;= g = g a Cons&#39;&#39; f &amp;gt;&amp;gt;= g = Cons&#39;&#39; (fmap (&amp;gt;&amp;gt;= g) f)Making an ApplicativeThe NonEmptyList&#39;&#39; variant actually has another well known name within thecommunity:data Free f a = Pure a | Free (f (Free f a))We favor this name over NonEmptyList&#39;&#39; from here on out. In the last sectionwe deferred writing the Applicative instance for Free but we can now presentits implementation. First, let’s gather some intuition around how we expect itto work by monomorphizing Free over Maybe and Int:&amp;gt;&amp;gt;&amp;gt; a = Free (Just (Free (Just (Pure (+1)))))&amp;gt;&amp;gt;&amp;gt; b = Pure 5&amp;gt;&amp;gt;&amp;gt; c = Free (Just (Pure 5))What should the result of a &amp;lt;*&amp;gt; b be? An argument could probably be made foreither: Free (Just (Free (Just (Pure 6)))) Pure 6What about for a &amp;lt;*&amp;gt; c? In this case, any one of the three answers is apotentially valid possibility: Free (Just (Free (Just (Free (Just (Pure 6)))))) Free (Just (Free (Just (Pure 6)))) Free (Just (Pure 6))This ambiguity is why we waited until we finished defining the Monad instance.Instead of trying to reason about which instance makes sense, we choose theinterpretation that aligns with our monad.ap :: forall f a b. Functor f =&amp;gt; Free f (a -&amp;gt; b) -&amp;gt; Free f a -&amp;gt; Free f bap f g = do f&#39; &amp;lt;- f g&#39; &amp;lt;- g pure (f&#39; g&#39;)Examining the results of ap a b and ap a c, we determine the first entriesof the above two lists must be the answer. Thus it is consistent to define ourApplicative like so:instance (Functor f) =&amp;gt; Applicative (Free f) where pure = Pure Pure f &amp;lt;*&amp;gt; g = fmap f g Free f &amp;lt;*&amp;gt; g = Free (fmap (&amp;lt;*&amp;gt; g) f)Algebraic Data TypesLet’s revisit our original questions: How can we go about converting a simple algebraic data type into a monad? Does there exist some set of minimal requirements the data type mustfulfill to make this conversion “free”? We have shown that a data type must be a Functor for us to build up a Freemonad. Additionally, as mentioned earlier, simple algebraicdata types are already functors, thereby answering both questions. To drivethis point home, consider the canonical Teletype example:data Teletype k = Read k | Write String k deriving FunctorArmed with this data type, we can generate programs using the Teletype DSL.For instance,read :: Free Teletype Stringread = Free (Read (Pure &quot;hello&quot;))write :: String -&amp;gt; Free Teletype ()write s = Free (Write s (Pure ()))readThenWrite :: Free Teletype ()readThenWrite = do input &amp;lt;- read write inputSmart constructors read and write are included to abstract away theboilerplate and help highlight readThenWrite’s role of syntax. Invoking thisfunction does not actually do anything, but reading the function makes it veryobvious what we at least want it to do. A corresponding handler provides themissing semantics:runReadThenWrite :: Free Teletype () -&amp;gt; IO ()runReadThenWrite (Free (Write s f)) = putStrLn s &amp;gt;&amp;gt; runReadThenWrite frunReadThenWrite (Free (Read f)) = runReadThenWrite frunReadThenWrite (Pure _) = pure ()Composing EffectsThough neither impressive nor particularly flexible, readThenWrite is anexample of a DSL corresponding to our Teletype effect. This is only halfthe battle though. As mentioned at the start, we want to be able to composeeffects together within the same program. After all, a program with just oneeffect doesn’t actually end up buying us much except a lot of unnecessaryabstraction.As we begin our journey down this road, let’s depart from Teletype and meet upwith hopefully a familiar friend:data State s k = Get (s -&amp;gt; k) | Put s k deriving FunctorIn the above snippet, State has been rewritten from our usual MTL-style to apseudo continuation-passing style compatible with Free. An example handlermight look like:runState :: forall s a. s -&amp;gt; Free (State s) a -&amp;gt; (s, a)runState s (Free (Get f)) = runState s (f s)runState _ (Free (Put s&#39; f)) = runState s&#39; frunState _ (Pure a) = aWe can then run this handler on a sample program like so:increment :: Free (State Int) ()increment = Free (Get (\\s -&amp;gt; Free (Put (s + 1) (Pure ()))))-- &amp;gt;&amp;gt;&amp;gt; runState 0 increment-- (1, ())Let’s raise the ante a bit. Suppose now we wanted to pass around a second state,e.g. a String. How might we go about doing this? Though we could certainlyrewrite increment to have state (Int, String) instead of Int, this feelsreminiscient to the expression problem.Having to update and recompile every one of our programs every time we introducesome new effect is a maintenance burden we should not settle on shouldering.Instead, we should aim to write all of our programs in a way that doesn’trequire modifying source.Sum TypesLet’s consider what it would take to compose effects State Int andState String together. In the world of data types, we usually employ eitherproducts or coproducts to bridge two disjoint types together. Let’s try thelatter and see where we end up:data (f :+: g) k = L (f k) | R (g k) deriving (Functor, Show)infixr 4 :+:This allows us to join types in the following manner:&amp;gt;&amp;gt;&amp;gt; L (Just 5) :: (Maybe :+: Identity) IntL (Just 5)&amp;gt;&amp;gt;&amp;gt; R (Identity 5) :: (Maybe :+: Identity) IntR (Identity 5)We call this chain of functors a signature. We can compose a signaturecontaining our Int and String state as well as a handler capable ofinterpreting it:runTwoState :: forall s1 s2 a . s1 -&amp;gt; s2 -&amp;gt; Free (State s1 :+: State s2) a -&amp;gt; (s1, s2, a)runTwoState s1 s2 (Free (L (Get f))) = runTwoState s1 s2 (f s1)runTwoState s1 s2 (Free (R (Get f))) = runTwoState s1 s2 (f s2)runTwoState _ s2 (Free (L (Put s1 f))) = runTwoState s1 s2 frunTwoState s1 _ (Free (R (Put s2 f))) = runTwoState s1 s2 frunTwoState s1 s2 (Pure a) = (s1, s2, a)It’s functional but hardly a solution. It requires manually writing everycombination of effects introduced by :+: - a straight up herculean task as thesignature gets longer. It also does not address the “expression problem”. Thatsaid, it does provide the scaffolding for a more polymorphic solution. We canbypass this combinatorial explosion of patterns by focusing on just one effectat a time, parameterizing the remainder of the signature. Handlers can then“peel” an effect off a signature, over and over, until we are out of effects topeel:runState&#39; :: forall s a sig. Functor sig =&amp;gt; s -&amp;gt; Free (State s :+: sig) a -&amp;gt; Free sig (s, a)runState&#39; s (Pure a) = pure (s, a)runState&#39; s (Free (L (Get f))) = runState&#39; s (f s)runState&#39; _ (Free (L (Put s f))) = runState&#39; s frunState&#39; s (Free (R other)) = Free (fmap (runState&#39; s) other)The above function combines the ideas of runState and runTwoState into amore general interface. Now programs containing State effects in any order canbe interpreted by properly ordering the handlers:threadedState :: Free (State Int :+: State String) ()threadedState = Free (L (Get (\\s1 -&amp;gt; Free (R (Get (\\s2 -&amp;gt; Free (L (Put (s1 + 1) (Free (R (Put (s2 ++ &quot;a&quot;) (Pure ()))))))))))))threadedState&#39; :: Free (State String :+: State Int) ()threadedState&#39; = ...-- &amp;gt;&amp;gt;&amp;gt; runState &quot;&quot; . runState&#39; @Int 0 $ threadedState-- (&quot;a&quot;,(1,()))-- &amp;gt;&amp;gt;&amp;gt; runState @Int 0 . runState&#39; &quot;&quot; $ threadedState&#39;-- (1,(&quot;a&quot;,()))MembershipWe can do better still. Our programs are far too concerned with the ordering oftheir corresponding signatures. The only thing they should care about is whetherthe effect exists at all. We can relax this coupling by introducing a newrecursive typeclass:class Member sub sup where inj :: sub a -&amp;gt; sup a prj :: sup a -&amp;gt; Maybe (sub a)Here sub is said to be a subtype of sup. inj allows us to promote thatsubtype to sup and prj allows us to dynamically downcast back to sub. Thistypeclass synergizes especially well with :+:. For instance, we expectState Int to be a subtype of State Int :+: State String. Importantly, we’dexpect the same for State String. Let’s consider how instances of Membermight look. First is reflexivity:instance Member sig sig where inj = id prj = JustThis instance should be fairly straightforward. We want to be able to cast atype to and from itself without issue. Next is left-occurrence:instance Member sig (sig :+: r) where inj = L prj (L f) = Just f prj _ = NothingThis is the pattern we’ve been working with up until now. Casting upwards isjust a matter of using the L data constructor while projecting back down worksso long as we are within the L context. Likewise there exists aright-recursion rule:instance (Member sig r) =&amp;gt; Member sig (l :+: r) where inj = R . inj prj (R g) = prj g prj _ = NothingLastly, as a convenience, we introduce left-recursion:instance Member sig (l1 :+: (l2 :+: r)) =&amp;gt; Member sig ((l1 :+: l2) :+: r) where inj sub = case inj sub of L l1 -&amp;gt; L (L l1) R (L l2) -&amp;gt; L (R l2) R (R r) -&amp;gt; R r prj sup = case sup of L (L l1) -&amp;gt; prj (L l1) L (R l2) -&amp;gt; prj (R (L l2)) R r -&amp;gt; prj (R (R r))The above allows us to operate on a tree of types rather than a list. We canread this as saying “subtying is not affected by how :+: is associated.” Warning These instances will not compile as is. A mixof TypeApplications and OVERLAPPING pragmas must be used. Refer to thegit repository for the realimplementation.With the above instances in place, we can now create a more flexibleimplementation of threadedState above:data Void k deriving Functorrun :: forall a. Free Void a -&amp;gt; arun (Pure a) = arun _ = error (pack &quot;impossible&quot;)threadedState&#39;&#39; :: Functor sig =&amp;gt; Member (State Int) sig =&amp;gt; Member (State String) sig =&amp;gt; Free sig ()threadedState&#39;&#39; = Free (inj (Get @Int (\\s1 -&amp;gt; Free (inj (Get (\\s2 -&amp;gt; Free (inj (Put (s1 + 1) (Free (inj (Put (s2 ++ &quot;a&quot;) (Pure ()))))))))))))-- &amp;gt;&amp;gt;&amp;gt; run . runState&#39; &quot;&quot; . runState&#39; @Int 0 $ threadedState&#39;&#39;-- (&quot;a&quot;,(1,()))-- &amp;gt;&amp;gt;&amp;gt; run . runState&#39; @Int 0 . runState&#39; &quot;&quot; $ threadedState&#39;&#39;-- (1,(&quot;a&quot;,()))A few takeaways: The program now stays polymorphic in type sig, We no longer explicitly mention L or R data constructors, and We use run to peel away the final effect.This flexibility grants us the ability to choose the order we handle effectsat the call site. By writing a few additional smart constructors, we could havea nicer program still:inject :: (Member sub sup) =&amp;gt; sub (Free sup a) -&amp;gt; Free sup ainject = Free . injproject :: (Member sub sup) =&amp;gt; Free sup a -&amp;gt; Maybe (sub (Free sup a))project (Free s) = prj sproject _ = Nothingget :: Functor sig =&amp;gt; Member (State s) sig =&amp;gt; Free sig sget = inject (Get pure)put :: Functor sig =&amp;gt; Member (State s) sig =&amp;gt; s -&amp;gt; Free sig ()put s = inject (Put s (pure ()))threadedStateM&#39;&#39; :: Functor sig =&amp;gt; Member (State Int) sig =&amp;gt; Member (State String) sig =&amp;gt; Free sig ()threadedStateM&#39;&#39; = do s1 &amp;lt;- get @Int s2 &amp;lt;- get @String put (s1 + 1) put (s2 ++ &quot;a&quot;) pure ()Higher-Order EffectsThis composition provides many benefits, but in certain situations we end uphitting a wall. To continue forward, we borrow an example fromEffect Handlers in Scope.In particular, we discuss exception handling and how we can use a free monad tosimulate throwing and catching exceptions.newtype Throw e k = Throw e deriving (Functor)throw e = inject (Throw e) Info To avoid too many distractions, we will sometimesskip writing type signatures.This Throw type should feel very intuitive at this point. We take an exceptionand “inject” it into our program using the throw smart constructor. What’s thecatch?catch (Pure a) _ = pure acatch (Free (L (Throw e))) h = h ecatch (Free (R other)) h = Free (fmap (`catch` h) other)In this scenario, catch traverses our program, happily passing values throughuntil it encounters a Throw. Our respective “peel” looks like so:runThrow :: forall e a sig. Free (Throw e :+: sig) a -&amp;gt; Free sig (Either e a)runThrow (Pure a) = pure (Right a)runThrow (Free (L (Throw e))) = pure (Left e)runThrow (Free (R other)) = Free (fmap runThrow other)We now have the requisite tools needed to build up and execute a sample programthat composes some State Int effect with a Throw effect:countDown :: forall sig. Functor sig =&amp;gt; Member (State Int) sig =&amp;gt; Member (Throw ()) sig =&amp;gt; Free sig ()countDown = do decr {- 1 -} catch (decr {- 2 -} &amp;gt;&amp;gt; decr {- 3 -}) pure where decr = do x &amp;lt;- get @Int if x &amp;gt; 0 then put (x - 1) else throw ()This program calls a potentially dangerous decr function three times, with thelast two attempts wrapped around a catch.Scoping ProblemsHow should the state of countDown be interpreted? There exist two reasonableoptions: If state is considered global, then successful decrements in catch shouldpersist. That is, our final state would be the initial value decrementedas many times as decr succeeds. If state is considered local, we expect catch to decrement state twicebut to rollback if an error is raised. If an error is caught, our finalstate would be the initial value decremented just the once.This is what it means for an operation to be scoped. In the local case,within the semantics of exception handling, the nested program within catchshould not affect the state of the world outside of it in the case of anexception. Let’s see if we can somehow write and invoke handlers accordingly:&amp;gt;&amp;gt;&amp;gt; run . runThrow @() . runState&#39; @Int 3 $ countDownRight (0,())The above snippet demonstrates a result we expect in either interpretation. Thenested decr &amp;gt;&amp;gt; decr raises no error. Likewise&amp;gt;&amp;gt;&amp;gt; run . runThrow @() . runState&#39; @Int 0 $ countDownLeft ()should also feel correct, regardless of interpretation. decr {- 1 -} ends upreturning a throw () which the subsequent runThrow handler interprets asLeft. What about the following?&amp;gt;&amp;gt;&amp;gt; run . runThrow @() . runState&#39; @Int 2 $ countDownRight (0,())This is an example of a global interpretation. Here we throw an error ondecr {- 3 -} but decr {- 2 -}’s effects persist despite existing within thecatch. So can we scope the operation? As it turns out, local semantics are outof reach. “Flattening” the program hopefully makes the reason clearer:countDown&#39; = Free (inj (Get @Int (\\x -&amp;gt; let a = \\k -&amp;gt; if x &amp;gt; 0 then Free (inj (Put (x - 1) k)) else throw () in a (catch (Free (inj (Get @Int (\\y -&amp;gt; let b = \\k -&amp;gt; if y &amp;gt; 0 then Free (inj (Put (y - 1) k)) else throw () in b (Free (inj (Get @Int (\\z -&amp;gt; let c = \\k -&amp;gt; if z &amp;gt; 0 then Free (inj (Put (z - 1) k)) else throw () in c (Pure ()))))))))) pure))))It’s noisy, but in the above snippet we see there exists no mechanism that“saves” the state prior to running the nested program.A Stronger FreeSomehow we need to ensure a nested (e.g. the program scoped within catch) doesnot “leak” in any way. To support programs within programs (within programswithin programs…) within the already recursively defined free monad, we looktowards a higher-level abstraction for help. According to Wu, Schrijvers, andHinze, A more direct solution [to handle some self-contained context] is to modelscoping constructs with higher-order syntax, where the syntax carries thosesyntax blocks directly.What would such a change look like? To answer that, it proves illustrativeunderstanding why our current definition of Free is insufficient. Considerwhat it means to “run” our program. We have a handler that traverses theprogram, operates on effects it knows how to operate on, and then returns aslightly less abstract program for the next handler to process. To save state,we somehow need each handler to refer to a context containing state asdefined by the handler prior.As a starting point, review our current definition of Free:data Free f a = Pure a | Free (f (Free f a))We see a is not something we, the effects library author, are in a position tomanipulate. To actually extract a value to be saved and threaded in a contextthough, we at the very least need this ability. So can we introduce some changethat give us this freedom? One idea is:data Free f a = Pure a | Free (f (Free f) a)The change is subtle but has potential provided we can get all the derived typemachinery working on this type instead. Take note! Previously the kind of fwas Type -&amp;gt; Type. In this new definition, we see it is now(Type -&amp;gt; Type) -&amp;gt; (Type -&amp;gt; Type). That is, f is now a function that mapsone type function to another. We have entered the world of higher-order kinds. Info f is usually a natural transformation, mappingone functor to another. The specifics regarding natural transformations aren’ttoo important here. Just note when we use the term going forward, we mean afunctor to functor mapping.Ideally we can extrapolate our learnings so far to this higher-order world. Ofmost importance is our Functor-constrained type variable f. Let’s dive a bitdeeper into what it currently buys us. First, take another look at how fmap isused within Free’s Monad instance:instance (Functor f) =&amp;gt; Monad (Free f) where Pure a &amp;gt;&amp;gt;= g = g a Free f &amp;gt;&amp;gt;= g = Free (fmap (&amp;gt;&amp;gt;= g) f)Its purpose is to allow extending our syntax, chaining different DSL termstogether into a bigger program. When we write e.g.readThenWrite = do input &amp;lt;- read write inputit is fmap that is responsible for piecing the read and write together.Second, re-examine a sample handler, e.g.runState&#39; s (Pure a) = pure (s, a)runState&#39; s (Free (L (Get f))) = runState&#39; s (f s)runState&#39; _ (Free (L (Put s f))) = runState&#39; s frunState&#39; s (Free (R other)) = Free (fmap (runState&#39; s) other)In this case, fmap is responsible for weaving the state semantics throughoutthe syntax. This is what allows us to interpret programs comprised of multipledifferent syntaxes. Whatever we end up building at the higher level needs tokeep both these aspects in mind.Higher-Order SyntaxSyntax is the easier of the two to resolve so that’s where we’ll first avert outattention. Extension requires two things: A higher-level concept of a functor to constrain our new f, and An fmap-like function capable of performing the extension.Building out (1) is fairly straightforward. Since f corresponds to a naturaltransformation, we create a mapping between functors like so:class HFunctor f where hmap :: (Functor m, Functor n) =&amp;gt; (forall x. m x -&amp;gt; n x) -&amp;gt; (forall x. f m x -&amp;gt; f n x)This allows us to lift transformations of e.g. Identity -&amp;gt; Maybe intof Identity -&amp;gt; f Maybe. Take a moment to notice the parallels between fmapand hmap. Building (2) is equally simple:class HFunctor f =&amp;gt; Syntax f where emap :: (m a -&amp;gt; m b) -&amp;gt; (f m a -&amp;gt; f m b)We designate emap as our fmap-extending equivalent. This is made obvious byseeing how Free ends up using emap:instance Syntax f =&amp;gt; Monad (Free f) where Pure a &amp;gt;&amp;gt;= g = g a Free f &amp;gt;&amp;gt;= g = Free (emap (&amp;gt;&amp;gt;= g) f)Once again, note the parallels betwen the Monad instances of both Frees.Higher-Order SemanticsThe more difficult problem lies on the semantic side of the equation. This partneeds to manage the threading of functions throughout potentially nestedeffects. To demonstrate, consider a revision to our Throw type that includes aCatch at the syntactic level:data Error e m a = Throw e | forall x. Catch (m x) (e -&amp;gt; m x) (x -&amp;gt; m a)We can create Error instances of our HFunctor and Syntax classes asfollows:instance HFunctor (Error e) where hmap _ (Throw x) = Throw x hmap t (Catch p h k) = Catch (t p) (t . h) (t . k)instance Syntax (Error e) where emap _ (Throw e) = Throw e emap f (Catch p h k) = Catch p h (f . k)This is all well and good, but now suppose we want to write a handler in thesame way we wrote runThrow earlier:runError :: forall e a sig. Syntax sig =&amp;gt; Free (Error e :+: sig) a -&amp;gt; Free sig (Either e a)runError (Pure a) = pure (Right a)runError (Free (L (Throw e))) = pure (Left e)runError (Free (L (Catch p h k))) = runError p &amp;gt;&amp;gt;= \\case Left e -&amp;gt; runError (h e) &amp;gt;&amp;gt;= \\case Left e&#39; -&amp;gt; pure (Left e&#39;) Right a -&amp;gt; runError (k a) Right a -&amp;gt; runError (k a)runError (Free (R other)) = Free _Make sure everything leading up to the last pattern makes sense and then askyourself how you might fill in the hole (_). We only have a few toolsat our disposal, namely hmap and emap. But, no matter how we choose tocompose them, hmap will let us down. In particular, our only means of“peeling” the signature is runError which is incompatible with the naturaltransformation hmap expects.We need another function specific for this weaving behavior, which we choose toadd to the Syntax typeclass:class HFunctor f =&amp;gt; Syntax f where emap :: (m a -&amp;gt; m b) -&amp;gt; (f m a -&amp;gt; f m b) weave :: (Monad m, Monad n, Functor ctx) =&amp;gt; ctx () -&amp;gt; Handler ctx m n -&amp;gt; (f m a -&amp;gt; f n (ctx a))type Handler ctx m n = forall x. ctx (m x) -&amp;gt; n (ctx x)Pay special attention to Handler. By introducing a functorial context (i.e.ctx), we have defined a function signature that more closely reflects that ofrunError. This is made clearer by instantiating ctx to Either e:type Handler m n = forall x. Either e (m x) -&amp;gt; n (Either e x)runError :: Free (Error e :+: sig) a -&amp;gt; Free sig (Either e a)Without ctx, weave would look just like hmap, highlighting how it’sparticularly well-suited to bypassing the hmap’s limitations. With weavealso comes expanded Syntax instances:instance (Syntax f, Syntax g) =&amp;gt; Syntax (f :+: g) where weave ctx hdl (L f) = L (weave ctx hdl f) weave ctx hdl (R g) = R (weave ctx hdl g)instance Syntax (Error e) where weave _ _ (Throw x) = Throw x weave ctx hdl (Catch p h k) = -- forall x. Catch (m x) (e -&amp;gt; m x) (x -&amp;gt; m a) Catch (hdl (fmap (const p) ctx)) (\\e -&amp;gt; hdl (fmap (const (h e)) ctx)) (hdl . fmap k)const is used solely to wrap our results in a way that hdl expects. Withthese instances fully defined, we can now finish our runError handler:runError (Free (R other)) = Free $ weave (Right ()) (either (pure . Left) runError) otherLiftingThe solution we’ve developed so far wouldn’t be especially useful if it wasweaker than the previous. As mentioned before, our new solution splits thefunctionality of fmap into extension and weaving. But nothing is stopping usfrom defining an instance that continues using fmap for both. Consider thefollowing:newtype Lift sig (m :: Type -&amp;gt; Type) a = Lift (sig (m a))Here sig refers to the lower-order data type we want to elevate to ourhigher-order Free, e.g. State s:type HState s = Lift (State s)hIncrement :: Free (Lift (State Int)) ()hIncrement = Free (Lift (Get (\\s -&amp;gt; Free (Lift (Put (s + 1) (Pure ()))))))type HVoid = Lift Voidrun :: Free HVoid a -&amp;gt; arun (Pure a) = arun _ = error (pack &quot;impossible&quot;)Here hIncrement is a lifted version of increment defined before. Likewise,run remains nearly identical to its previous definition. Making Lift aninstance of Syntax is a equally straightforward: instance Functor sig =&amp;gt; HFunctor (Lift sig) where hmap t (Lift f) = Lift (fmap t f) instance Functor sig =&amp;gt; Syntax (Lift sig) where emap t (Lift f) = Lift (fmap t f) weave ctx hdl (Lift f) = Lift (fmap (\\p -&amp;gt; hdl (fmap (const p) ctx)) f)The corresponding smart constructors and state handler should look like before,but with our ctx now carrying the state around:get :: forall s sig. HFunctor sig =&amp;gt; Member (HState s) sig =&amp;gt; Free sig sget = inject (Lift (Get Pure))put :: forall s sig. HFunctor sig =&amp;gt; Member (HState s) sig =&amp;gt; s -&amp;gt; Free sig ()put s = inject (Lift (Put s (pure ())))runState :: forall s a sig. Syntax sig =&amp;gt; s -&amp;gt; Free (HState s :+: sig) a -&amp;gt; Free sig (s, a)runState s (Pure a) = pure (s, a)runState s (Free (L (Lift (Get f)))) = runState s (f s)runState _ (Free (L (Lift (Put s f)))) = runState s frunState s (Free (R other)) = Free (weave (s, ()) hdl other) where hdl :: forall x. (s, Free (HState s :+: sig) x) -&amp;gt; Free sig (s, x) hdl = uncurry runStateWith all this in place, we can finally construct our countDown example again:countDown :: forall sig. Syntax sig =&amp;gt; Member (HState Int) sig =&amp;gt; Member (Error ()) sig =&amp;gt; Free sig ()countDown = do decr {- 1 -} catch (decr {- 2 -} &amp;gt;&amp;gt; decr {- 3 -}) pure where decr = do x &amp;lt;- get @Int if x &amp;gt; 0 then put (x - 1) else throw ()Now if we encounter an error within our catch statement, the local statesemantics are respected:&amp;gt;&amp;gt;&amp;gt; run . runError @() . runState @Int 2 $ countDownRight (1,())Pay attention to why this works - we first use our runState handler andeventually encounter decr {- 3 -} which returns throw () instead ofput (x - 1). During this process, weave was invoked on a Catch with context(s, ) used to maintain the state at the time. Next runError is invoked whichsees the Catch, encounters the returned Throw after running the scopedprogram, and invokes the error handler which has our saved state.LimitationsThough the higher-order free implementation is largely a useful tool formanaging effects, it is not perfect. I’ve had an especially hard time gettingresource-oriented effects working, e.g. with custom effects like so:data Server hdl conn (m :: * -&amp;gt; *) k where Start :: SpawnOptions -&amp;gt; Server hdl conn m hdl Stop :: hdl -&amp;gt; Server hdl conn m ExitCode GetPort :: hdl -&amp;gt; Server hdl conn m PortNumber Open :: Text -&amp;gt; PortNumber -&amp;gt; Server hdl conn m conn Close :: conn -&amp;gt; Server hdl conn m ()The issue here being running the custom Server handler invokes start andstop when wrapped in some bracket-likeinterface, even if the bracketed code has not yet finished. I have settled onworkarounds, but these workarounds consist of just structuring these kind ofeffects differently.In general, modeling asynchronous or IO-oriented operations feel “unsolved”with solutions resorting to some forkliftstrategy or other ad-hoc solutions that don’t feel as cemented in literature. Idon’t necessarily think these are the wrong approach (I frankly don’t knowenough to have a real opinion here), but it’d be nice to feel there was someconsensus as to what a non-hacky solution theoretically looks like.Additionally, it is cumbersome remembering the order handlers should be appliedto achieve the desired global vs. local state semantics. This is not exclusivelya problem of free effect systems (e.g. MTL also suffers from this), but theissue feels more prominent here.ConclusionI will continue exploring effect systems à la free, but I am admittedly notyet convinced they are the right way forward. Unfortunately, they can be hard toreason about with unexpected interactions between effects if not careful. I amsure a large contributing factor to this conclusion is the lack ofbeginner-oriented documentation regarding proper use and edge cases. Just tobuild up this post required reading source code of multiple effects librariesand scattered blog posts, watching various YouTube videos, etc. And, despite allthat, I am still not confident I understand the implementation details behindcertain key abstractions. Hopefully this entry threads the needle betweenexposition and overt jargon to get us a little closer though.  Though there exists a categorical definition of what makes something free, in this case it suffices to substitute “free” with “systematic”. &amp;#8617; " }, { "title": "Tagless Final Parsing", "url": "/posts/tagless-final-parsing/", "categories": "Programming", "tags": "haskell, functional, programming", "date": "2021-12-26 00:00:00 -0500", "snippet": "In his introductory text,Oleg Kiselyov discusses the tagless final strategy for implementing DSLs.The approach permits leveraging the strong typing provided by some host languagein a performant way. This post combines key thoughts from a selection of papersand code written on the topic. We conclude with an implementation of aninterpreter for a toy language that runs quickly, remains strongly-typed, andcan be extended without modification. Introduction Initial Encoding Single Pass Resource Usage Type Safety Expression Problem Tagless Final Leibniz Equality Dynamics Interpretations Expression Revisited Copy Symantics Limitations ConclusionIntroductionTo get started, let’s write what our toy language will look like. 1234567891011121314 digit = ? any number between 0-9 ? ;(* We ignore any leading 0s *)integer = digit, { digit } ;e_integer = [ e_integer, (&quot;+&quot; | &quot;-&quot;) ] , ( &quot;(&quot;, e_integer, &quot;)&quot; | integer ) ;boolean = &quot;true&quot; | &quot;false&quot; ;e_boolean = [ e_boolean, (&quot;&amp;amp;&amp;amp;&quot; | &quot;||&quot;) ] , ( &quot;(&quot;, e_boolean, &quot;)&quot; | boolean ) ;expr = e_integer | e_boolean ; The above expresses addition, subtraction, conjunction, and disjunction, to beinterpreted in the standard way. All operations are left-associative, withdefault precedence disrupted via parenthesis (()). Our goal is to usemegaparsec to interpretprograms in this language, raising errors on malformed or invalidly-typedinputs. We will evaluate interpreter performance on inputs such as thosegenerated byecho {1..10000000} | sed &#39;s/ / + /g&#39; &amp;gt; input.txt Info To support inputs like above, ideally we mix lazyand strict functionality. For example, we should lazily load in a file butstrictly evaluate its contents. Certain languages struggle without this morenuanced evaluation strategy, e.g. $ (echo -n &#39;print(&#39; &amp;amp;&amp;amp; echo -n {1..10000000} &amp;amp;&amp;amp; echo &#39;)&#39;) | sed &#39;s/ / + /g&#39; &amp;gt; input.py$ python3 input.pySegmentation fault: 11 Note it’d actually be more efficient on our end to not use megaparsec at all!The library loads in the entirety of to-be-parsed text into memory, but using itwill hopefully be more representative of projects out in the wild.Initial EncodingHow might we instinctively choose to tackle an interpreter of our language? Asone might expect, megaparsec already has all the tooling needed to parseexpressions. We can represent our expressions and results straightforwardly likeso:data Expr = EInt Integer | EBool Bool | EAdd Expr Expr | ESub Expr Expr | EAnd Expr Expr | EOr Expr Expr deriving (Show)data Result = RInt Integer | RBool Bool deriving (Eq)We use a standard ADT to describe the structure of our program, nesting thesame data type recursively to represent precedence. For instance, we wouldexpect a (so-far fictional) function parse to give us&amp;gt;&amp;gt;&amp;gt; parse &quot;1 + 2 + 3&quot;EAdd (EAdd (EInt 1) (EInt 2)) (EInt 3)We can then evaluate expressions within our Expr type. Notice we must wrap ourresult within some Error-like monad considering the ADT does not necessarilycorrespond to a well-typed expression in our language.asInt :: Result -&amp;gt; Either Text IntegerasInt (RInt e) = pure easInt _ = Left &quot;Could not cast integer.&quot;asBool :: Result -&amp;gt; Either Text BoolasBool (RBool e) = pure easBool _ = Left &quot;Could not cast boolean.&quot;toResult :: Expr -&amp;gt; Either Text ResulttoResult (EInt e) = pure $ RInt etoResult (EBool e) = pure $ RBool etoResult (EAdd lhs rhs) = do lhs&#39; &amp;lt;- toResult lhs &amp;gt;&amp;gt;= asInt rhs&#39; &amp;lt;- toResult rhs &amp;gt;&amp;gt;= asInt pure $ RInt (lhs&#39; + rhs&#39;)toResult (ESub lhs rhs) = do lhs&#39; &amp;lt;- toResult lhs &amp;gt;&amp;gt;= asInt rhs&#39; &amp;lt;- toResult rhs &amp;gt;&amp;gt;= asInt pure $ RInt (lhs&#39; - rhs&#39;)toResult (EAnd lhs rhs) = do lhs&#39; &amp;lt;- toResult lhs &amp;gt;&amp;gt;= asBool rhs&#39; &amp;lt;- toResult rhs &amp;gt;&amp;gt;= asBool pure $ RBool (lhs&#39; &amp;amp;&amp;amp; rhs&#39;)toResult (EOr lhs rhs) = do lhs&#39; &amp;lt;- toResult lhs &amp;gt;&amp;gt;= asBool rhs&#39; &amp;lt;- toResult rhs &amp;gt;&amp;gt;= asBool pure $ RBool (lhs&#39; || rhs&#39;)With the above in place, we can begin fleshing out our first parsing attempt. Anaive solution may look as follows:parseNaive :: Parser ResultparseNaive = expr &amp;gt;&amp;gt;= either (fail . unpack) pure . toResult where expr = E.makeExprParser term [ [binary &quot;+&quot; EAdd, binary &quot;-&quot; ESub] , [binary &quot;&amp;amp;&amp;amp;&quot; EAnd, binary &quot;||&quot; EOr] ] binary name f = E.InfixL (f &amp;lt;$ symbol name) term = parens expr &amp;lt;|&amp;gt; EInt &amp;lt;$&amp;gt; integer &amp;lt;|&amp;gt; EBool &amp;lt;$&amp;gt; booleanThere are certainly components of the above implementation that raises eyebrows(at least in the context of large inputs), but that could potentially beoverlooked depending on how well it runs. Running parseNaive1 againstinput.txt shows little promise though:$ cabal run --enable-profiling exe:initial-encoding -- input.txt +RTS -s50000005000000... 4126 MiB total memory in use (0 MB lost due to fragmentation)... Total time 25.541s ( 27.121s elapsed)... Productivity 82.3% of total user, 78.9% of total elapsedA few immediate takeaways from this exercise:This solution has to run through the generated AST twice. First to build the AST and secondto type-check and evaluate the code (i.e. toResult). is resource intensive. It consumes a large amount of memory (approximately4 GiB in the above run) and is far too slow. A stream of 10,000,000 integersshould be quick and cheap to sum together. is unsafe. Packaged as a library, there are no typing guarantees we leveragefrom our host language. For example, expression EAnd (EInt 1) (EInt 2) isvalid. suffers from the expression problem.Developers cannot extend our language with new operations without having tomodify the source.Let’s tackle each of these problems in turn.Single PassOur naive attempt separated parsing from evaluation because they fail indifferent ways. The former raises a ParseErrorBundle on invalid input whilethe latter raises a Text on mismatched types. Ideally we would have a singleerror type shared by both of these failure modes. Unfortunately, this is not sosimple - the Operator types found within makeExprParser have incompatiblefunction signatures. In particular, InfixL is defined asInfixL :: m (a -&amp;gt; a -&amp;gt; a) -&amp;gt; Operator m ainstead ofInfixL :: (a -&amp;gt; a -&amp;gt; m a) -&amp;gt; Operator m aTo work around these limitations, we define our binary functions to operate andreturn on values of type Either Text Expr. We then raise a Left on typemismatch, deferring error reporting at the Parser level until the currentexpression is fully parsed:parseSingle :: Parser ResultparseSingle = expr &amp;gt;&amp;gt;= either (fail . unpack) pure where expr = E.makeExprParser term [ [binary &quot;+&quot; asInt EInt EAdd, binary &quot;-&quot; asInt EInt ESub] , [binary &quot;&amp;amp;&amp;amp;&quot; asBool EBool EAnd, binary &quot;||&quot; asBool EBool EOr ] ] binary name cast f bin = E.InfixL do void $ symbol name pure $ \\lhs rhs -&amp;gt; do lhs&#39; &amp;lt;- lhs &amp;gt;&amp;gt;= cast rhs&#39; &amp;lt;- rhs &amp;gt;&amp;gt;= cast toResult $ bin (f lhs&#39;) (f rhs&#39;) term = parens expr &amp;lt;|&amp;gt; Right . RInt &amp;lt;$&amp;gt; integer &amp;lt;|&amp;gt; Right . RBool &amp;lt;$&amp;gt; booleanResource UsageThough our above strategy avoids two explicit passes through the AST, lazinesssets it up so that we build this intertwined callstack without actuallyevaluating anything until we interpret the returned Result. The generatedruntime statistics are actually worse as a result:cabal run --enable-profiling exe:initial-encoding -- \\ input.txt -m single +RTS -sWe’ll use a heap profile to make the implementation’s shortcomings more obvious:cabal run --enable-profiling exe:initial-encoding -- \\ input.txt -m single +RTS -hr Tip To iterate faster, reduce the number of integers ininput.txt. The resulting heap profile should remain proportional to theoriginal. Just make sure the program runs for long enough to actually performmeaningful profiling. This section works on inputs of 100,000 integers.The generated heap profile, broken down by retainer set, looks as follows:Our top-level expression parser continues growing in size until the programnears completion, presumably when the expression is finally evaluated. Tofurther pinpoint the leaky methods, we re-run the heap generation by cost-centrestack to get:Even our straightforward lexing functions are holding on to memory. The lazinessand left associative nature of our grammar hints that we may be dealing with athunk stack reminiscient of foldl.This implies we could fix the issue by evaluating our data strictly with e.g.deepseq. The problem isunfortunately deeper than this though. Consider the definition of InfixL’sparser:pInfixL :: MonadPlus m =&amp;gt; m (a -&amp;gt; a -&amp;gt; a) -&amp;gt; m a -&amp;gt; a -&amp;gt; m apInfixL op p x = do f &amp;lt;- op y &amp;lt;- p let r = f x y pInfixL op p r &amp;lt;|&amp;gt; return rBecause this implementation uses the backtracking alternative operator (&amp;lt;|&amp;gt;),we must also hold onto each &amp;lt;|&amp;gt; return r in memory “just in case” we need touse it. Since we are working with a left-factoredgrammar, we can drop the alternatives and apply strictness with a customexpression parser:parseStrict :: Parser ResultparseStrict = term &amp;gt;&amp;gt;= expr where expr t = do op &amp;lt;- M.option Nothing $ Just &amp;lt;$&amp;gt; ops case op of Just OpAdd -&amp;gt; nest t asInt EInt EAdd Just OpSub -&amp;gt; nest t asInt EInt ESub Just OpAnd -&amp;gt; nest t asBool EBool EAnd Just OpOr -&amp;gt; nest t asBool EBool EOr _ -&amp;gt; pure t nest :: forall a . Result -&amp;gt; (Result -&amp;gt; Either Text a) -&amp;gt; (a -&amp;gt; Expr) -&amp;gt; (Expr -&amp;gt; Expr -&amp;gt; Expr) -&amp;gt; Parser Result nest t cast f bin = do t&#39; &amp;lt;- term a &amp;lt;- either (fail . unpack) pure do lhs &amp;lt;- cast t rhs &amp;lt;- cast t&#39; toResult $ bin (f lhs) (f rhs) a `deepseq` expr a term = do p &amp;lt;- M.option Nothing $ Just &amp;lt;$&amp;gt; symbol &quot;(&quot; if isJust p then (term &amp;gt;&amp;gt;= expr) &amp;lt;* symbol &quot;)&quot; else RInt &amp;lt;$&amp;gt; integer &amp;lt;|&amp;gt; RBool &amp;lt;$&amp;gt; booleanThis implementation runs marginally faster and uses a constant amount of memory: Info ARR_WORDS corresponds to the ByteStringconstructor and is unavoidable so long as we use megaparsec.To get a better sense of where runtime tends to reside, let’s re-run our newlystrict implementation on our 10,000,000 file again alongside a time profile:echo {1..10000000} | sed &#39;s/ / + /g&#39; &amp;gt; input.txtcabal run --enable-profiling exe:initial-encoding -- \\ input.txt -m strict +RTS -pspace Text.Megaparsec.Lexer Text/Megaparsec/Lexer.hs:(68,1)-(71,44) 54.9 57.3decimal Text.Megaparsec.Char.Lexer Text/Megaparsec/Char/Lexer.hs:363:1-32 24.7 21.4lexeme Text.Megaparsec.Lexer Text/Megaparsec/Lexer.hs:87:1-23 12.6 15.7ops Parser.Utils src/Parser/Utils.hs:(69,1)-(74,3) 2.6 2.7toResult Parser.Initial src/Parser/Initial.hs:(62,1)-(79,29) 2.3 2.2run Main app/Main.hs:(42,1)-(54,58) 1.6 0.6readTextDevice Data.Text.Internal.IO libraries/text/src/Data/Text/Internal/IO.hs:133:39-64 1.3 0.0Surprisingly, the vast majority of time (roughly 95%) is spent parsing. As such,we won’t worry ourselves about runtime any further.Type SafetyLet’s next explore how we can empower library users with a stricter version ofthe Expr monotype. In particular, we want to prohibit construction of invalidexpressions. A common strategy is to promote our ADT to a GADT:data GExpr a where GInt :: Integer -&amp;gt; GExpr Integer GBool :: Bool -&amp;gt; GExpr Bool GAdd :: GExpr Integer -&amp;gt; GExpr Integer -&amp;gt; GExpr Integer GSub :: GExpr Integer -&amp;gt; GExpr Integer -&amp;gt; GExpr Integer GAnd :: GExpr Bool -&amp;gt; GExpr Bool -&amp;gt; GExpr Bool GOr :: GExpr Bool -&amp;gt; GExpr Bool -&amp;gt; GExpr BoolBy virtue of working with arbitrary, potentially mis-typed input, we musteventually perform some form of type-checking on our input. To get the GADTrepresentation working requires additional machinery like existential datatypesand Rank2Types. The end user of our library reaps the benefits though,acquiring a strongly-typed representation of our AST:data Wrapper = forall a. Show a =&amp;gt; Wrapper (GExpr a)parseGadt :: Parser WrapperparseGadt = term &amp;gt;&amp;gt;= expr where ... nest :: forall b . Show b =&amp;gt; Wrapper -&amp;gt; (forall a. GExpr a -&amp;gt; Either Text (GExpr b)) -&amp;gt; (b -&amp;gt; GExpr b) -&amp;gt; (GExpr b -&amp;gt; GExpr b -&amp;gt; GExpr b) -&amp;gt; Parser Wrapper nest (Wrapper t) cast f bin = do Wrapper t&#39; &amp;lt;- term case (cast t, cast t&#39;) of (Right lhs, Right rhs) -&amp;gt; do let z = eval $ bin lhs rhs z `seq` expr (Wrapper $ f z) (Left e, _) -&amp;gt; fail $ unpack e (_, Left e) -&amp;gt; fail $ unpack eWe hide the full details here (refer to the linked Github repository for thefull implementation), but note the changes are minimal outside of thesignatures/data types required to make our existentially quantified type work.Users of the parser can now unwrap the Wrapper type and resume like normal. Warning This is an arguable “improvement” consideringconvenience takes a dramatic hit. It is awkward working with the Wrappertype.Expression ProblemLastly comes the expression problem, and one that is fundamentally unsolvablegiven our current implementation. By nature of (G)ADTs, all data-types areclosed. It is not extensible since that would break any static type guaranteesaround e.g. pattern matching. To fix this (and other problems still present inour implementation), we contrast our initial encoding to that of tagless final.Tagless FinalLet’s re-think our GADT example above and refactor it into a typeclass:class Symantics repr where eInt :: Integer -&amp;gt; repr Integer eBool :: Bool -&amp;gt; repr Bool eAdd :: repr Integer -&amp;gt; repr Integer -&amp;gt; repr Integer eSub :: repr Integer -&amp;gt; repr Integer -&amp;gt; repr Integer eAnd :: repr Bool -&amp;gt; repr Bool -&amp;gt; repr Bool eOr :: repr Bool -&amp;gt; repr Bool -&amp;gt; repr BoolThis should look familiar. Instances of GExpr have been substituted by aparameter repr of kind * -&amp;gt; *. Kiselyov describes typeclasses used this wayas a means of defining a class of interpreters. An example interpreter couldlook like evaluation from before:newtype Eval a = Eval {runEval :: a}instance Symantics Eval where eInt = Eval eBool = Eval eAdd (Eval lhs) (Eval rhs) = Eval (lhs + rhs) eSub (Eval lhs) (Eval rhs) = Eval (lhs - rhs) eAnd (Eval lhs) (Eval rhs) = Eval (lhs &amp;amp;&amp;amp; rhs) eOr (Eval lhs) (Eval rhs) = Eval (lhs || rhs)To belabor the similarities between the two a bit further, compare the followingtwo examples side-by-side:let expr = foldl&#39; eAdd (eInt 0) $ take count (eInt &amp;lt;$&amp;gt; [1..])let expr = foldl&#39; EAdd (EInt 0) $ take count (EInt &amp;lt;$&amp;gt; [1..])Outside of some capitalization, the encodings are exactly the same. Consideringthese similarities, it’s clear type safety is not a concern like it was withExpr. This new paradigm also allows us to write both an implementation thatparallels the memory usage of above as well as a propersolution to the expression problem. To follow along though first requires aquick detour into leibniz equalities.Leibniz EqualityLeibniz equality states that two objects are equivalent provided they can besubstituted in all contexts without issue. Consider the definition provided bythe eq package:newtype a := b = Refl {subst :: forall c. c a -&amp;gt; c b}Here we are saying two types a and b actually refer to the same type if itturns out that simultaneously• Maybe a ~ Maybe b• Either String a ~ Either String b• Identity a ~ Identity b• ...and so on, where ~ refers to equality constraints.Let’s clarify further with an example. Suppose we had types A and B andwanted to ensure they were actually the same type. Then there must exist afunction subst with signature c A -&amp;gt; c B for all c. What might thatfunction look like? It turns out there is only one acceptable choice: id.This might not seem particularly valuable at first glance, but what it doespermit is a means of proving equality at the type-level and in a way Haskell’stype system respects. For instance, the following is valid:&amp;gt;&amp;gt;&amp;gt; import Data.Eq.Type ((:=)(..))&amp;gt;&amp;gt;&amp;gt; :set -XTypeOperators-- Type-level equality is reflexive. I can prove it since-- `id` is a suitable candidate for `subst`.&amp;gt;&amp;gt;&amp;gt; refl = Refl id&amp;gt;&amp;gt;&amp;gt; :t reflrefl :: b := b-- Haskell can verify our types truly are the same.&amp;gt;&amp;gt;&amp;gt; a = refl :: (Integer := Integer)&amp;gt;&amp;gt;&amp;gt; a = refl :: (Integer := Bool)&amp;lt;interactive&amp;gt;:7:5: error: • Couldn&#39;t match type ‘Integer’ with ‘Bool’We can also prove less obvious things at the type-level and take advantage ofthis later on. As an exercise, consider how you might express the following:functionEquality :: a1 := a2 -&amp;gt; b1 := b2 -&amp;gt; (a1 -&amp;gt; b1) := (a2 -&amp;gt; b2)That is, if a1 and a2 are the same types, and b1 and b2 are the sametypes, then functions of type a1 -&amp;gt; b1 can equivalently be expressed asfunctions from a2 -&amp;gt; b2. Answer I suggest reading from the bottom up to better understand why this works. import Data.Eq.Type ((:=)(..), refl)newtype F1 t b a = F1 {runF1 :: t := (a -&amp;gt; b)}newtype F2 t a b = F2 {runF2 :: t := (a -&amp;gt; b)}functionEquality :: forall a1 a2 b1 b2 . a1 := a2 -&amp;gt; b1 := b2 -&amp;gt; (a1 -&amp;gt; b1) := (a2 -&amp;gt; b2)functionEquality (Refl s1) -- s1 :: forall c. c a1 -&amp;gt; c a2 (Refl s2) -- s2 :: forall c. c b1 -&amp;gt; c b2 = runF2 -- (a1 -&amp;gt; b1) := (a2 -&amp;gt; b2) . s2 -- F2 (a1 -&amp;gt; b1) a2 b2 . F2 -- F2 (a1 -&amp;gt; b1) a2 b1 . runF1 -- (a1 -&amp;gt; b1) := (a2 -&amp;gt; b1) . s1 -- F1 (a1 -&amp;gt; b1) b1 a2 . F1 -- F1 (a1 -&amp;gt; b1) b1 a1 $ refl -- (a1 -&amp;gt; b1) := (a1 -&amp;gt; b1) DynamicsWithin our GADTs example, we introduced data type Wrapper to allow us to passaround GADTs of internally different type (e.g. GExpr Integer vs.GExpr Bool) within the same context. We can do something similar viaDynamics in the tagless final world. Though we could use the already availabledynamicslibrary, we’ll build our own for exploration’s sake.First, let’s create a representation of the types in our grammar:class Typeable repr where pInt :: repr Integer pBool :: repr Boolnewtype TQ t = TQ {runTQ :: forall repr. Typeable repr =&amp;gt; repr t}instance Typeable TQ where pInt = TQ pInt pBool = TQ pBoolTQ takes advantage of polymorphic constructors to allow us to wrap anycompatible Typeable member function and “reinterpret” it as something else.For example, we can create new Typeable instances like so:newtype AsInt a = AsInt (Maybe (a := Integer))instance Typeable AsInt where pInt = AsInt (Just refl) pBool = AsInt Nothingnewtype AsBool a = AsBool (Maybe (a := Bool))instance Typeable AsBool where pInt = AsBool Nothing pBool = AsBool (Just refl)We can then use TQ to check if something is of the appropriate type:&amp;gt;&amp;gt;&amp;gt; import Data.Maybe (isJust)&amp;gt;&amp;gt;&amp;gt; tq = pInt :: TQ Integer&amp;gt;&amp;gt;&amp;gt; case runTQ tq of AsInt a -&amp;gt; isJust aTrue&amp;gt;&amp;gt;&amp;gt; case runTQ tq of AsBool a -&amp;gt; isJust aFalseEven more interestingly, we can bundle this type representation alongside avalue of the corresponding type, yielding our desired Dynamic:import qualified Data.Eq.Type as EQdata Dynamic repr = forall t. Dynamic (TQ t) (repr t)class IsDynamic a where type&#39; :: forall repr. Typeable repr =&amp;gt; repr a lift&#39; :: forall repr. Symantics repr =&amp;gt; a -&amp;gt; repr a cast&#39; :: forall repr t. TQ t -&amp;gt; Maybe (t := a)instance IsDynamic Integer where type&#39; = pInt lift&#39; = eInt cast&#39; (TQ t) = case t of AsInt a -&amp;gt; ainstance IsDynamic Bool where type&#39; = pBool lift&#39; = eBool cast&#39; (TQ t) = case t of AsBool a -&amp;gt; atoDyn :: forall repr a. IsDynamic a =&amp;gt; Symantics repr =&amp;gt; a -&amp;gt; Dynamic reprtoDyn = Dynamic type&#39; . lift&#39;fromDyn :: forall repr a. IsDynamic a =&amp;gt; Dynamic repr -&amp;gt; Maybe (repr a)fromDyn (Dynamic t e) = case t of (cast&#39; -&amp;gt; r) -&amp;gt; do r&#39; &amp;lt;- r pure $ EQ.coerce (EQ.lift r&#39;) e&amp;gt;&amp;gt;&amp;gt; a = toDyn 5 :: Dynamic Expr&amp;gt;&amp;gt;&amp;gt; runExpr &amp;lt;$&amp;gt; fromDyn a :: Maybe IntegerJust 5By maintaining a leibniz equality within our Dynamic instances (i.e. AsInt),we can internally coerce the wrapped value into the actual type we care about.With this background information in place, we can finally devise an expressionparser similar to the parser we’ve written using initial encoding:parseStrict :: forall repr . NFData (Dynamic repr) =&amp;gt; Symantics repr =&amp;gt; Parser (Dynamic repr)parseStrict = term &amp;gt;&amp;gt;= expr where expr :: Dynamic repr -&amp;gt; Parser (Dynamic repr) expr t = do op &amp;lt;- M.option Nothing $ Just &amp;lt;$&amp;gt; ops case op of Just OpAdd -&amp;gt; nest t eAdd OpAdd Just OpSub -&amp;gt; nest t eSub OpSub Just OpAnd -&amp;gt; nest t eAnd OpAnd Just OpOr -&amp;gt; nest t eOr OpOr _ -&amp;gt; pure t nest :: forall a . IsDynamic a =&amp;gt; Dynamic repr -&amp;gt; (repr a -&amp;gt; repr a -&amp;gt; repr a) -&amp;gt; Op -&amp;gt; Parser (Dynamic repr) nest t bin op = do t&#39; &amp;lt;- term case binDyn bin t t&#39; of Nothing -&amp;gt; fail $ &quot;Invalid operands for `&quot; &amp;lt;&amp;gt; show op &amp;lt;&amp;gt; &quot;`&quot; Just a -&amp;gt; a `deepseq` expr a term :: Parser (Dynamic repr) term = do p &amp;lt;- M.option Nothing $ Just &amp;lt;$&amp;gt; symbol &quot;(&quot; if isJust p then (term &amp;gt;&amp;gt;= expr) &amp;lt;* symbol &quot;)&quot; else toDyn &amp;lt;$&amp;gt; integer &amp;lt;|&amp;gt; toDyn &amp;lt;$&amp;gt; booleanInterpretationsSo far we’ve seen very little benefit switching to this strategy despite thelevel of complexity this change introduces. Here we’ll pose a question thathopefully makes at least one benefit more obvious. Suppose we wanted tointerpret the parsed expression in two different ways. First, we want a basicevaluator, and second we want a pretty-printer. In our initial encodingstrategy, the evaluator has already been defined:eval :: GExpr a -&amp;gt; aWe say eval is one possible interpreter over GExpr. It takes in GExprs andreduces them into literal values. How would a pretty printer work? One candidateinterpreter could look as follows:pPrint :: GExpr a -&amp;gt; TextpPrint (GInt e) = pack $ show epPrint (GBool e) = pack $ show epPrint (GAdd lhs rhs) = &quot;(&quot; &amp;lt;&amp;gt; pPrint lhs &amp;lt;&amp;gt; &quot; + &quot; &amp;lt;&amp;gt; pPrint rhs &amp;lt;&amp;gt; &quot;)&quot;...Unfortunately using this definition requires fundamentally changing how our GADTparser works. parseGadt currently makes certain optimizations based on thefact only eval has been needed so far, reducing the expression as we traversethe input stream. Generalizing the parser to take in any function of signatureforall b. (forall a. GExpr a) -&amp;gt; b (i.e. the signature of some genericinterpreter) would force us to retain memory or accept additional arguments tomake our function especially generic to accommodate.2On the other hand, our tagless final approach expects multiple interpretationsfrom the outset. We can define a newtype likenewtype PPrint a = PPrint {runPPrint :: a}instance Symantics PPrint where eInt = PPrint . pack . show eBool = PPrint . pack . show eAdd (PPrint lhs) (PPrint rhs) = PPrint $ &quot;(&quot; &amp;lt;&amp;gt; lhs &amp;lt;&amp;gt; &quot; + &quot; &amp;lt;&amp;gt; rhs &amp;lt;&amp;gt; &quot;)&quot; ...and interpret ourparseStrict :: forall repr. Symantics repr =&amp;gt; Parser (Dynamic repr)Parser as a Dynamic PPrint instead of a Dynamic Eval without losing anypreviously acquired gains.Expression RevisitedThere does exist a major caveat with our tagless final interpreters. If owning asingle Dynamic instance, how exactly are we able to interpret this in multipleways? After all, a Dynamic cannot be of type Dynamic Eval andDynamic PPrint. What we’d like to be able to do is maintain a genericDynamic repr and reinterpret it at will.One solution comes in the form of another newtype around a polymorphicconstructor:newtype SQ a = SQ {runSQ :: forall repr. Symantics repr =&amp;gt; repr a}instance Symantics SQ where eInt e = SQ (eInt e) eBool e = SQ (eBool e) eAdd (SQ lhs) (SQ rhs) = SQ (eAdd lhs rhs) eSub (SQ lhs) (SQ rhs) = SQ (eSub lhs rhs) eAnd (SQ lhs) (SQ rhs) = SQ (eAnd lhs rhs) eOr (SQ lhs) (SQ rhs) = SQ (eOr lhs rhs)We can then run evaluation and pretty-printing on the same entity:data Result = RInt Integer | RBool BoolrunBoth :: Dynamic SQ -&amp;gt; Maybe (Result, Text)runBoth d = case fromDyn d of Just (SQ q) -&amp;gt; pure ( case q of Eval a -&amp;gt; RInt a , case q of PPrint a -&amp;gt; a ) Nothing -&amp;gt; case fromDyn d of Just (SQ q) -&amp;gt; pure ( case q of Eval a -&amp;gt; RBool a , case q of PPrint a -&amp;gt; a ) Nothing -&amp;gt; NothingThis has an unintended side effect though. By using SQ, we effectively closeour type universe. Suppose we now wanted to extend our Symantics type with anew multiplication operator (*). We could do so by writing typeclass:class MulSymantics repr where eMul :: repr Integer -&amp;gt; repr Integer -&amp;gt; repr Integerinstance MulSymantics Eval where eMul (Eval lhs) (Eval rhs) = Eval (lhs * rhs)instance MulSymantics PPrint where eMul (PPrint lhs) (PPrint rhs) = PPrint $ &quot;(&quot; &amp;lt;&amp;gt; lhs &amp;lt;&amp;gt; &quot; * &quot; &amp;lt;&amp;gt; rhs &amp;lt;&amp;gt; &quot;)&quot; Warning Naturally we also need to extend our parser tobe aware of the new operator as well. To avoid diving yet further into theweeds, we do not do that here.But this typeclass is excluded from our SQ type. We’re forced to write yetanother SQ-like wrapper, e.g.newtype MSQ a = MSQ {runMSQ :: forall repr. MulSymantics repr =&amp;gt; repr a}just to keep up. This in turn forces us to redefine all functions that operatedon SQ.Copy SymanticsWe can reformulate this more openly, abandoning any sort of Rank2 constructorswithin our newtypes by choosing to track multiple representationssimultaneously:data SCopy repr1 repr2 a = SCopy (repr1 a) (repr2 a)instance (Symantics repr1, Symantics repr2) =&amp;gt; Symantics (SCopy repr1 repr2) where eInt e = SCopy (eInt e) (eInt e) eBool e = SCopy (eBool e) (eBool e) eAdd (SCopy a1 a2) (SCopy b1 b2) = SCopy (eAdd a1 b1) (eAdd a2 b2) eSub (SCopy a1 a2) (SCopy b1 b2) = SCopy (eSub a1 b1) (eSub a2 b2) eAnd (SCopy a1 a2) (SCopy b1 b2) = SCopy (eAnd a1 b1) (eAnd a2 b2) eOr (SCopy a1 a2) (SCopy b1 b2) = SCopy (eOr a1 b1) (eOr a2 b2)instance (MulSymantics repr1, MulSymantics repr2) =&amp;gt; MulSymantics (SCopy repr1 repr2) where eMul (SCopy a1 a2) (SCopy b1 b2) = SCopy (eMul a1 b1) (eMul a2 b2)As we define new classes of operators on our Integer and Bool types, we makeSCopy an instance of them. We can then “thread” the second representationthroughout our function calls like so:runEval&#39; :: forall repr . Dynamic (SCopy Eval repr) -&amp;gt; Maybe (Result, Dynamic repr)runEval&#39; d = case fromDyn d :: Maybe (SCopy Eval repr Integer) of Just (SCopy (Eval a) r) -&amp;gt; pure (RInt a, Dynamic pInt r) Nothing -&amp;gt; case fromDyn d :: Maybe (SCopy Eval repr Bool) of Just (SCopy (Eval a) r) -&amp;gt; pure (RBool a, Dynamic pBool r) Nothing -&amp;gt; NothingrunPPrint&#39; :: forall repr . Dynamic (SCopy PPrint repr) -&amp;gt; Maybe (Text, Dynamic repr)runPPrint&#39; d = case fromDyn d :: Maybe (SCopy PPrint repr Text) of Just (SCopy (PPrint a) r) -&amp;gt; pure (a, Dynamic pText r) Nothing -&amp;gt; NothingrunBoth&#39; :: forall repr . Dynamic (SCopy Eval (SCopy PPrint repr)) -&amp;gt; Maybe (Result, Text, Dynamic repr)runBoth&#39; d = do (r, d&#39;) &amp;lt;- runEval&#39; d (p, d&#39;&#39;) &amp;lt;- runPPrint&#39; d&#39; pure (r, p, d&#39;&#39;)Notice each function places a Dynamic repr of unknown representation in thelast position of each return tuple. The caller is then able to interpret thisextra repr as they wish, composing them in arbitrary ways (e.g. runBoth&#39;).LimitationsThe expression problem is only partially solved with our Dynamic strategy. Iffor instance we wanted to add a new literal type, e.g. a String, we wouldunfortunately need to append to the Typeable and Dynamic definitions tosupport them. The standard dynamics package only allows monomorphicvalues so in this sense we are stuck. If only needing to add additionalfunctionality to the existing set of types though, we can extend at will.ConclusionI was initially hoping to extend this post further with a discussion aroundexplicit sharing as noted here, but thispost is already getting too long. I covered only a portion of the topics OlegKiselyov wrote about, but covered at least the majority of topics I’ve so farbeen exploring in my own personal projects. I will note that the tagless finalapproach, while certainly useful, also does add a fair level of cognitiveoverhead in my experience. Remembering the details around dynamics especiallyis what prompted me to write this post to begin with.  Code here and elsewhere found in the tagless-final-parsing repository. &amp;#8617; These “additional arguments” are effectively how the tagless final strategy works. The interface is much cleaner though considering all methods are passed around implicity via the Symantics typeclass. &amp;#8617; " } ]
