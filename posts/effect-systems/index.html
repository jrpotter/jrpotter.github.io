<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="Effect Systems" /><meta property="og:locale" content="en" /><meta name="description" content="As I’ve begun exploring the world of so-called algebraic effect systems, I’ve become increasingly frustrated in the level of documentation around them. Learning to use them (and moreso understanding how they work) requires diving into library internals, watching various videos, and hoping to grok why certain effects aren’t being interpreted the way you might have hoped. My goal in this post is to address this issue, at least to some degree, in a focused, pedagogical fashion." /><meta property="og:description" content="As I’ve begun exploring the world of so-called algebraic effect systems, I’ve become increasingly frustrated in the level of documentation around them. Learning to use them (and moreso understanding how they work) requires diving into library internals, watching various videos, and hoping to grok why certain effects aren’t being interpreted the way you might have hoped. My goal in this post is to address this issue, at least to some degree, in a focused, pedagogical fashion." /><link rel="canonical" href="https://jrpotter.github.io/posts/effect-systems/" /><meta property="og:url" content="https://jrpotter.github.io/posts/effect-systems/" /><meta property="og:site_name" content="Joshua Potter" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-03-21T00:00:00-04:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Effect Systems" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"As I’ve begun exploring the world of so-called algebraic effect systems, I’ve become increasingly frustrated in the level of documentation around them. Learning to use them (and moreso understanding how they work) requires diving into library internals, watching various videos, and hoping to grok why certain effects aren’t being interpreted the way you might have hoped. My goal in this post is to address this issue, at least to some degree, in a focused, pedagogical fashion.","url":"https://jrpotter.github.io/posts/effect-systems/","@type":"BlogPosting","headline":"Effect Systems","dateModified":"2022-03-21T00:00:00-04:00","datePublished":"2022-03-21T00:00:00-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://jrpotter.github.io/posts/effect-systems/"},"@context":"https://schema.org"}</script><title>Effect Systems | Joshua Potter</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Joshua Potter"><meta name="application-name" content="Joshua Potter"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://avatars.githubusercontent.com/u/3267697?v=4" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Joshua Potter</a></div><div class="site-subtitle font-italic">A series of personal explorations.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/projects/" class="nav-link"> <i class="fa-fw fas fa-project-diagram ml-xl-3 mr-xl-3 unloaded"></i> <span>PROJECTS</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/jrpotter" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Effect Systems</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Effect Systems</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Joshua Potter </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Mar 21, 2022, 12:00 AM -0400" >Mar 21<i class="unloaded">2022-03-21T00:00:00-04:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6624 words">36 min read</span></div></div><div class="post-content"><p>As I’ve begun exploring the world of so-called <strong>algebraic effect systems</strong>, I’ve become increasingly frustrated in the level of documentation around them. Learning to use them (and moreso understanding how they work) requires diving into library internals, watching various videos, and hoping to grok why certain effects aren’t being interpreted the way you might have hoped. My goal in this post is to address this issue, at least to some degree, in a focused, pedagogical fashion.</p><p>A large portion of this post has been derived from the implementation of the <a href="https://hackage.haskell.org/package/fused-effects">fused-effects</a> library, chosen because it seems to have the most active development, the smallest dependency footprint, and minimal type machinery. In turn, this library was largely inspired by Nicolas Wu, Tom Schrijvers, and Ralf Hinze’s work in <a href="https://www.cs.ox.ac.uk/people/nicolas.wu/papers/Scope.pdf">Effect Handlers in Scope</a>. As such, we’ll discuss choice parts of this paper as well.</p><p>Code snippets can be found in <a href="https://github.com/jrpotter/effect-systems">this git repository</a>.</p><ul id="markdown-toc"><li><a href="#free-monads" id="markdown-toc-free-monads">Free Monads</a><ul><li><a href="#making-a-monad" id="markdown-toc-making-a-monad">Making a Monad</a><li><a href="#making-an-applicative" id="markdown-toc-making-an-applicative">Making an Applicative</a><li><a href="#algebraic-data-types" id="markdown-toc-algebraic-data-types">Algebraic Data Types</a></ul><li><a href="#composing-effects" id="markdown-toc-composing-effects">Composing Effects</a><ul><li><a href="#sum-types" id="markdown-toc-sum-types">Sum Types</a><li><a href="#membership" id="markdown-toc-membership">Membership</a></ul><li><a href="#higher-order-effects" id="markdown-toc-higher-order-effects">Higher-Order Effects</a><ul><li><a href="#scoping-problems" id="markdown-toc-scoping-problems">Scoping Problems</a><li><a href="#a-stronger-free" id="markdown-toc-a-stronger-free">A Stronger Free</a><ul><li><a href="#higher-order-syntax" id="markdown-toc-higher-order-syntax">Higher-Order Syntax</a><li><a href="#higher-order-semantics" id="markdown-toc-higher-order-semantics">Higher-Order Semantics</a><li><a href="#lifting" id="markdown-toc-lifting">Lifting</a></ul></ul><li><a href="#limitations" id="markdown-toc-limitations">Limitations</a><li><a href="#conclusion" id="markdown-toc-conclusion">Conclusion</a></ul><h1 id="free-monads">Free Monads</h1><p>To begin our exploration, let’s pose a few questions:</p><ol><li>How can we go about converting a simple algebraic data type into a monad?<li>Does there exist some set of minimal requirements the data type must fulfill to make this conversion “free”?<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></ol><p>To help guide our decision making, we’ll examine the internals of some arbitrary monad. More concretely, let’s see what <code class="language-plaintext highlighter-rouge">1 + 2</code> could look like within a monadic context:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">onePlusTwo</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">m</span><span class="o">.</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="kt">Int</span>
<span class="n">onePlusTwo</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">a</span> <span class="o">&lt;-</span> <span class="n">pure</span> <span class="mi">1</span>
  <span class="n">b</span> <span class="o">&lt;-</span> <span class="n">pure</span> <span class="mi">2</span>
  <span class="n">pure</span> <span class="o">$</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></table></code></div></div><p>The above won’t win any awards, but it should be illustrative enough for our purposes. <code class="language-plaintext highlighter-rouge">do</code> is just syntactic sugar for repeated bind applications (<code class="language-plaintext highlighter-rouge">&gt;&gt;=</code>), so we could’ve written the above alternatively as:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">onePlusTwo'</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">m</span><span class="o">.</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="kt">Int</span>
<span class="n">onePlusTwo'</span> <span class="o">=</span> <span class="n">pure</span> <span class="mi">1</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">pure</span> <span class="mi">2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">pure</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)))</span>
</pre></table></code></div></div><p>This is where we’ll pause for a moment and squint. We see that <code class="language-plaintext highlighter-rouge">do</code> syntax desugars into something that looks awfully close to a (non-empty) list! Let’s compare the above with how we might define that:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kr">data</span> <span class="kt">NonEmptyList</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Last</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Cons</span> <span class="n">a</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">NonEmptyList</span> <span class="n">a</span><span class="p">)</span>

<span class="n">onePlusTwo''</span> <span class="o">::</span> <span class="kt">NonEmptyList</span> <span class="kt">Int</span>
<span class="n">onePlusTwo''</span> <span class="o">=</span> <span class="kt">Cons</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Cons</span> <span class="mi">2</span> <span class="p">(</span><span class="nf">\</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Last</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)))</span>

<span class="n">runNonEmptyList</span> <span class="o">::</span> <span class="kt">NonEmptyList</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">runNonEmptyList</span> <span class="p">(</span><span class="kt">Last</span> <span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>
<span class="n">runNonEmptyList</span> <span class="p">(</span><span class="kt">Cons</span> <span class="n">a</span> <span class="n">f</span><span class="p">)</span> <span class="o">=</span> <span class="n">runNonEmptyList</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span>

<span class="c1">-- &gt;&gt;&gt; runIdentity onePlusTwo'</span>
<span class="c1">-- 3</span>
<span class="c1">-- &gt;&gt;&gt; runNonEmptyList onePlusTwo''</span>
<span class="c1">-- 3</span>
</pre></table></code></div></div><p>Take a moment to appreciate the rough pseudo-equivalence of <code class="language-plaintext highlighter-rouge">NonEmptyList</code> and a monad. Also take a moment to appreciate the differences. Because we no longer employ the bind operator anywhere within our function definitions, we have effectively separated the <strong>syntax</strong> of our original function from its <strong>semantics</strong>. That is, <code class="language-plaintext highlighter-rouge">onePlusTwo''</code> can be viewed as a <em>program</em> in and of itself, and the <code class="language-plaintext highlighter-rouge">runNonEmptyList</code> <strong>handler</strong> can be viewed as the interpretation of said program.</p><h2 id="making-a-monad">Making a Monad</h2><p><code class="language-plaintext highlighter-rouge">NonEmptyList</code> was formulated from a monad, so it’s natural to think perhaps it too is a monad. Unfortunately this is not the case - it isn’t even a functor! Give it a try or use <code class="language-plaintext highlighter-rouge">{-# LANGUAGE DeriveFunctor #-}</code> to ask the compiler to make an attempt on your behalf.</p><div class="alert alert-success" role="alert"><div><i class="fa fa-lightbulb"></i> <strong>Tip</strong></div><p>Type variable <code class="language-plaintext highlighter-rouge">a</code> is said to be contravariant with respect to <code class="language-plaintext highlighter-rouge">Cons</code>. That is, <code class="language-plaintext highlighter-rouge">a</code> resides in a <a href="https://www.fpcomplete.com/blog/2016/11/covariance-contravariance/">negative position</a> within <code class="language-plaintext highlighter-rouge">Cons</code>’s function.</p></div><p>If we can’t make this a monad as is, are there a minimal number of changes we could introduce to make it happen? Ideally our changes maintain the “shape” of the data type as much as possible, thereby maintaining the integrity behind the original derivation. Since our current roadblock stems from type variable <code class="language-plaintext highlighter-rouge">a</code>’s position in <code class="language-plaintext highlighter-rouge">Cons</code>, let’s see what happens if we just abstract it away:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kr">data</span> <span class="kt">NonEmptyList'</span> <span class="n">f</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Last'</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Cons'</span> <span class="n">a</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="kt">NonEmptyList'</span> <span class="n">f</span> <span class="n">a</span><span class="p">))</span>
</pre></table></code></div></div><p>With general parameter <code class="language-plaintext highlighter-rouge">f</code> now in the place of <code class="language-plaintext highlighter-rouge">(-&gt;) a</code>, a functor derivation becomes possible provided <code class="language-plaintext highlighter-rouge">f</code> is also a <code class="language-plaintext highlighter-rouge">Functor</code>:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kr">instance</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">NonEmptyList'</span> <span class="n">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Last'</span> <span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Last'</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Cons'</span> <span class="n">a</span> <span class="n">ts</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Cons'</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span><span class="p">)</span> <span class="n">g</span><span class="p">)</span>
</pre></table></code></div></div><p>And though we needed to modify our syntax and semantics slightly, the proposed changes do not lose us out on anything of real consequence:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">twoPlusThree</span> <span class="o">::</span> <span class="kt">NonEmptyList'</span> <span class="p">(</span><span class="kt">Reader</span> <span class="kt">Int</span><span class="p">)</span> <span class="kt">Int</span>
<span class="n">twoPlusThree</span> <span class="o">=</span> <span class="kt">Cons'</span>
  <span class="mi">2</span> <span class="p">(</span><span class="n">reader</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Cons'</span>
    <span class="mi">3</span> <span class="p">(</span><span class="n">reader</span> <span class="p">(</span><span class="nf">\</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Last'</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)))))</span>

<span class="n">runNonEmptyList'</span> <span class="o">::</span> <span class="kt">NonEmptyList'</span> <span class="p">(</span><span class="kt">Reader</span> <span class="kt">Int</span><span class="p">)</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">runNonEmptyList'</span> <span class="p">(</span><span class="kt">Last'</span> <span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>
<span class="n">runNonEmptyList'</span> <span class="p">(</span><span class="kt">Cons'</span> <span class="n">a</span> <span class="n">f</span><span class="p">)</span> <span class="o">=</span> <span class="n">runNonEmptyList'</span> <span class="p">(</span><span class="n">runReader</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span>

<span class="c1">-- &gt;&gt;&gt; runNonEmptyList' twoPlusThree</span>
<span class="c1">-- 5</span>
</pre></table></code></div></div><p>Compare the above snippet with <code class="language-plaintext highlighter-rouge">onePlusTwo'</code>.</p><hr /><p>The <code class="language-plaintext highlighter-rouge">Applicative</code> instance is slightly more involved so we’ll hold off on that front for the time-being. For the sake of forging ahead though, assume it exists. With the <code class="language-plaintext highlighter-rouge">Functor</code> instance established and the <code class="language-plaintext highlighter-rouge">Applicative</code> instance assumed, we are ready to tackle writing the <code class="language-plaintext highlighter-rouge">Monad</code> instance. A first attempt would probably look like the following:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kr">instance</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">NonEmptyList'</span> <span class="n">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="kt">NonEmptyList'</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">NonEmptyList'</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">NonEmptyList'</span> <span class="n">f</span> <span class="n">b</span>
  <span class="kt">Last'</span> <span class="n">a</span>   <span class="o">&gt;&gt;=</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span> <span class="n">a</span>
  <span class="kt">Cons'</span> <span class="n">a</span> <span class="n">f</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span> <span class="o">=</span> <span class="kt">Cons'</span> <span class="kr">_</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="o">&gt;&gt;=</span> <span class="n">g</span><span class="p">)</span> <span class="n">f</span><span class="p">)</span>
</pre></table></code></div></div><p>Defining bind (<code class="language-plaintext highlighter-rouge">&gt;&gt;=</code>) on <code class="language-plaintext highlighter-rouge">Last'</code> is straightforward, but <code class="language-plaintext highlighter-rouge">Cons'</code> again presents a problem. With <code class="language-plaintext highlighter-rouge">g</code> serving as our only recourse of converting an <code class="language-plaintext highlighter-rouge">a</code> into anything, how should we fill in the hole (<code class="language-plaintext highlighter-rouge">_</code>)? One approach could be:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kr">instance</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">NonEmptyList'</span> <span class="n">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">Cons'</span> <span class="n">a</span> <span class="n">f</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span> <span class="o">=</span>
    <span class="kr">let</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">&gt;&gt;=</span> <span class="n">g</span><span class="p">)</span> <span class="n">f</span>
     <span class="kr">in</span> <span class="kr">case</span> <span class="n">g</span> <span class="n">a</span> <span class="kr">of</span>
          <span class="kt">Last'</span> <span class="n">b</span>    <span class="o">-&gt;</span> <span class="kt">Cons'</span> <span class="n">b</span> <span class="n">ts</span>
          <span class="kt">Cons'</span> <span class="n">b</span> <span class="n">f'</span> <span class="o">-&gt;</span> <span class="kt">Cons'</span> <span class="n">b</span> <span class="p">(</span><span class="n">f'</span> <span class="o">&lt;&gt;</span> <span class="n">ts</span><span class="p">)</span>
</pre></table></code></div></div><p>but this is pretty unsatisfactory. This definition requires a <code class="language-plaintext highlighter-rouge">Semigroup</code> constraint on <code class="language-plaintext highlighter-rouge">f</code>, which in turn requires some lifting operator. After all, how else could we append <code class="language-plaintext highlighter-rouge">Last a1 &lt;&gt; Last a2</code> together? Suddenly the list of constraints on <code class="language-plaintext highlighter-rouge">f</code> is growing despite our best intentions. Let’s take a step back and see if there is something else we can try.</p><p>The insight falls from the one constraint we had already added (admittedly without much fanfare). That is, we are requiring type variable <code class="language-plaintext highlighter-rouge">f</code> to be a <code class="language-plaintext highlighter-rouge">Functor</code>! With this in mind, we can actually massage our first parameter into a bind-compatible one by simply omitting it altogether.</p><p>To elaborate, it is <a href="https://bartoszmilewski.com/2015/02/03/functoriality/">well known</a> simple algebraic data types are isomorphic to “primitive” functors (<code class="language-plaintext highlighter-rouge">Identity</code> and <code class="language-plaintext highlighter-rouge">Const</code>) and that (co)products of functors yield more functors. We can therefore “absorb” the syntax of <code class="language-plaintext highlighter-rouge">a</code> <em>into</em> <code class="language-plaintext highlighter-rouge">f</code> by using a product type as a container of sorts:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kr">data</span> <span class="kt">NonEmptyList''</span> <span class="n">f</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Last''</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Cons''</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="kt">NonEmptyList''</span> <span class="n">f</span> <span class="n">a</span><span class="p">))</span>

<span class="kr">data</span> <span class="kt">Container</span> <span class="n">a</span> <span class="n">m</span> <span class="n">k</span> <span class="o">=</span> <span class="kt">Container</span> <span class="n">a</span> <span class="p">(</span><span class="n">m</span> <span class="n">k</span><span class="p">)</span> <span class="kr">deriving</span> <span class="kt">Functor</span>

<span class="n">threePlusFour</span> <span class="o">::</span> <span class="kt">NonEmptyList''</span> <span class="p">(</span><span class="kt">Container</span> <span class="kt">Int</span> <span class="p">(</span><span class="kt">Reader</span> <span class="kt">Int</span><span class="p">))</span> <span class="kt">Int</span>
<span class="n">threePlusFour</span> <span class="o">=</span> <span class="kt">Cons''</span>
  <span class="p">(</span><span class="kt">Container</span> <span class="mi">3</span> <span class="p">(</span><span class="n">reader</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Cons''</span>
    <span class="p">(</span><span class="kt">Container</span> <span class="mi">4</span> <span class="p">(</span><span class="n">reader</span> <span class="p">(</span><span class="nf">\</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Last''</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)))))))</span>

<span class="n">runNonEmptyList''</span> <span class="o">::</span> <span class="kt">NonEmptyList''</span> <span class="p">(</span><span class="kt">Container</span> <span class="kt">Int</span> <span class="p">(</span><span class="kt">Reader</span> <span class="kt">Int</span><span class="p">))</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">runNonEmptyList''</span> <span class="p">(</span><span class="kt">Last''</span> <span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>
<span class="n">runNonEmptyList''</span> <span class="p">(</span><span class="kt">Cons''</span> <span class="p">(</span><span class="kt">Container</span> <span class="n">a</span> <span class="n">f</span><span class="p">))</span> <span class="o">=</span> <span class="n">runNonEmptyList''</span> <span class="p">(</span><span class="n">runReader</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span>

<span class="c1">-- &gt;&gt;&gt; runNonEmptyList'' threePlusFour</span>
<span class="c1">-- 7</span>
</pre></table></code></div></div><p>The above demonstrates <code class="language-plaintext highlighter-rouge">NonEmptyList'</code> was in fact overly specific for our purposes. By generalizing further still, we lose no expressivity and gain the capacity to finally write our <code class="language-plaintext highlighter-rouge">Monad</code> instance:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kr">instance</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">NonEmptyList''</span> <span class="n">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">Last''</span> <span class="n">a</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span> <span class="n">a</span>
  <span class="kt">Cons''</span> <span class="n">f</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span> <span class="o">=</span> <span class="kt">Cons''</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="o">&gt;&gt;=</span> <span class="n">g</span><span class="p">)</span> <span class="n">f</span><span class="p">)</span>
</pre></table></code></div></div><h2 id="making-an-applicative">Making an Applicative</h2><p>The <code class="language-plaintext highlighter-rouge">NonEmptyList''</code> variant actually has another well known name within the community:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kr">data</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Pure</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Free</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">f</span> <span class="n">a</span><span class="p">))</span>
</pre></table></code></div></div><p>We favor this name over <code class="language-plaintext highlighter-rouge">NonEmptyList''</code> from here on out. In the last section we deferred writing the <code class="language-plaintext highlighter-rouge">Applicative</code> instance for <code class="language-plaintext highlighter-rouge">Free</code> but we can now present its implementation. First, let’s gather some intuition around how we expect it to work by monomorphizing <code class="language-plaintext highlighter-rouge">Free</code> over <code class="language-plaintext highlighter-rouge">Maybe</code> and <code class="language-plaintext highlighter-rouge">Int</code>:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Free</span> <span class="p">(</span><span class="kt">Just</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">Just</span> <span class="p">(</span><span class="kt">Pure</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)))))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">Pure</span> <span class="mi">5</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="kt">Free</span> <span class="p">(</span><span class="kt">Just</span> <span class="p">(</span><span class="kt">Pure</span> <span class="mi">5</span><span class="p">))</span>
</pre></table></code></div></div><p>What should the result of <code class="language-plaintext highlighter-rouge">a &lt;*&gt; b</code> be? An argument could probably be made for either:</p><ol><li><code class="language-plaintext highlighter-rouge">Free (Just (Free (Just (Pure 6))))</code><li><code class="language-plaintext highlighter-rouge">Pure 6</code></ol><p>What about for <code class="language-plaintext highlighter-rouge">a &lt;*&gt; c</code>? In this case, any one of the three answers is a potentially valid possibility:</p><ol><li><code class="language-plaintext highlighter-rouge">Free (Just (Free (Just (Free (Just (Pure 6))))))</code><li><code class="language-plaintext highlighter-rouge">Free (Just (Free (Just (Pure 6))))</code><li><code class="language-plaintext highlighter-rouge">Free (Just (Pure 6))</code></ol><p>This ambiguity is why we waited until we finished defining the <code class="language-plaintext highlighter-rouge">Monad</code> instance. Instead of trying to reason about which instance makes sense, we choose the interpretation that aligns with our monad.</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">ap</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span><span class="o">.</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">b</span>
<span class="n">ap</span> <span class="n">f</span> <span class="n">g</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">f'</span> <span class="o">&lt;-</span> <span class="n">f</span>
  <span class="n">g'</span> <span class="o">&lt;-</span> <span class="n">g</span>
  <span class="n">pure</span> <span class="p">(</span><span class="n">f'</span> <span class="n">g'</span><span class="p">)</span>
</pre></table></code></div></div><p>Examining the results of <code class="language-plaintext highlighter-rouge">ap a b</code> and <code class="language-plaintext highlighter-rouge">ap a c</code>, we determine the first entries of the above two lists must be the answer. Thus it is consistent to define our <code class="language-plaintext highlighter-rouge">Applicative</code> like so:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kr">instance</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Applicative</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">pure</span> <span class="o">=</span> <span class="kt">Pure</span>

  <span class="kt">Pure</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">g</span> <span class="o">=</span> <span class="n">fmap</span> <span class="n">f</span> <span class="n">g</span>
  <span class="kt">Free</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">g</span> <span class="o">=</span> <span class="kt">Free</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="o">&lt;*&gt;</span> <span class="n">g</span><span class="p">)</span> <span class="n">f</span><span class="p">)</span>
</pre></table></code></div></div><h2 id="algebraic-data-types">Algebraic Data Types</h2><p>Let’s revisit our original questions:</p><blockquote><ol><li>How can we go about converting a simple algebraic data type into a monad?<li>Does there exist some set of minimal requirements the data type must fulfill to make this conversion “free”?</ol></blockquote><p>We have shown that a data type must be a <code class="language-plaintext highlighter-rouge">Functor</code> for us to build up a <code class="language-plaintext highlighter-rouge">Free</code> monad. Additionally, as <a href="#making-a-monad">mentioned earlier</a>, simple algebraic data types are <em>already</em> functors, thereby answering both questions. To drive this point home, consider the canonical <code class="language-plaintext highlighter-rouge">Teletype</code> example:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kr">data</span> <span class="kt">Teletype</span> <span class="n">k</span> <span class="o">=</span> <span class="kt">Read</span> <span class="n">k</span> <span class="o">|</span> <span class="kt">Write</span> <span class="kt">String</span> <span class="n">k</span> <span class="kr">deriving</span> <span class="kt">Functor</span>
</pre></table></code></div></div><p>Armed with this data type, we can generate programs using the <code class="language-plaintext highlighter-rouge">Teletype</code> DSL. For instance,</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">read</span> <span class="o">::</span> <span class="kt">Free</span> <span class="kt">Teletype</span> <span class="kt">String</span>
<span class="n">read</span> <span class="o">=</span> <span class="kt">Free</span> <span class="p">(</span><span class="kt">Read</span> <span class="p">(</span><span class="kt">Pure</span> <span class="s">"hello"</span><span class="p">))</span>

<span class="n">write</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="kt">Teletype</span> <span class="nb">()</span>
<span class="n">write</span> <span class="n">s</span> <span class="o">=</span> <span class="kt">Free</span> <span class="p">(</span><span class="kt">Write</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Pure</span> <span class="nb">()</span><span class="p">))</span>

<span class="n">readThenWrite</span> <span class="o">::</span> <span class="kt">Free</span> <span class="kt">Teletype</span> <span class="nb">()</span>
<span class="n">readThenWrite</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">input</span> <span class="o">&lt;-</span> <span class="n">read</span>
  <span class="n">write</span> <span class="n">input</span>
</pre></table></code></div></div><p>Smart constructors <code class="language-plaintext highlighter-rouge">read</code> and <code class="language-plaintext highlighter-rouge">write</code> are included to abstract away the boilerplate and help highlight <code class="language-plaintext highlighter-rouge">readThenWrite</code>’s role of syntax. Invoking this function does not actually <em>do</em> anything, but reading the function makes it very obvious what we at least <em>want</em> it to do. A corresponding handler provides the missing semantics:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">runReadThenWrite</span> <span class="o">::</span> <span class="kt">Free</span> <span class="kt">Teletype</span> <span class="nb">()</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">runReadThenWrite</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">Write</span> <span class="n">s</span> <span class="n">f</span><span class="p">))</span> <span class="o">=</span> <span class="n">putStrLn</span> <span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="n">runReadThenWrite</span> <span class="n">f</span>
<span class="n">runReadThenWrite</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">Read</span> <span class="n">f</span><span class="p">))</span> <span class="o">=</span> <span class="n">runReadThenWrite</span> <span class="n">f</span>
<span class="n">runReadThenWrite</span> <span class="p">(</span><span class="kt">Pure</span> <span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">pure</span> <span class="nb">()</span>
</pre></table></code></div></div><h1 id="composing-effects">Composing Effects</h1><p>Though neither impressive nor particularly flexible, <code class="language-plaintext highlighter-rouge">readThenWrite</code> is an example of a DSL corresponding to our <code class="language-plaintext highlighter-rouge">Teletype</code> <strong>effect</strong>. This is only half the battle though. As mentioned at the start, we want to be able to compose effects together within the same program. After all, a program with just one effect doesn’t actually end up buying us much except a lot of unnecessary abstraction.</p><p>As we begin our journey down this road, let’s depart from <code class="language-plaintext highlighter-rouge">Teletype</code> and meet up with hopefully a familiar friend:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kr">data</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">k</span> <span class="o">=</span> <span class="kt">Get</span> <span class="p">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="p">)</span> <span class="o">|</span> <span class="kt">Put</span> <span class="n">s</span> <span class="n">k</span>
  <span class="kr">deriving</span> <span class="kt">Functor</span>
</pre></table></code></div></div><p>In the above snippet, <code class="language-plaintext highlighter-rouge">State</code> has been rewritten from our usual MTL-style to a pseudo continuation-passing style compatible with <code class="language-plaintext highlighter-rouge">Free</code>. An example handler might look like:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">runState</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">s</span> <span class="n">a</span><span class="o">.</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="p">(</span><span class="kt">State</span> <span class="n">s</span><span class="p">)</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">runState</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">Get</span> <span class="n">f</span><span class="p">))</span> <span class="o">=</span> <span class="n">runState</span> <span class="n">s</span> <span class="p">(</span><span class="n">f</span> <span class="n">s</span><span class="p">)</span>
<span class="n">runState</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">Put</span> <span class="n">s'</span> <span class="n">f</span><span class="p">))</span> <span class="o">=</span> <span class="n">runState</span> <span class="n">s'</span> <span class="n">f</span>
<span class="n">runState</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Pure</span> <span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>
</pre></table></code></div></div><p>We can then run this handler on a sample program like so:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">increment</span> <span class="o">::</span> <span class="kt">Free</span> <span class="p">(</span><span class="kt">State</span> <span class="kt">Int</span><span class="p">)</span> <span class="nb">()</span>
<span class="n">increment</span> <span class="o">=</span> <span class="kt">Free</span> <span class="p">(</span><span class="kt">Get</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="p">(</span><span class="kt">Put</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Pure</span> <span class="nb">()</span><span class="p">))))</span>

<span class="c1">-- &gt;&gt;&gt; runState 0 increment</span>
<span class="c1">-- (1, ())</span>
</pre></table></code></div></div><p>Let’s raise the ante a bit. Suppose now we wanted to pass around a second state, e.g. a <code class="language-plaintext highlighter-rouge">String</code>. How might we go about doing this? Though we could certainly rewrite <code class="language-plaintext highlighter-rouge">increment</code> to have state <code class="language-plaintext highlighter-rouge">(Int, String)</code> instead of <code class="language-plaintext highlighter-rouge">Int</code>, this feels reminiscient to the <a href="/posts/tagless-final-parsing#expression-problem">expression problem</a>. Having to update and recompile every one of our programs every time we introduce some new effect is a maintenance burden we should not settle on shouldering. Instead, we should aim to write all of our programs in a way that doesn’t require modifying source.</p><h2 id="sum-types">Sum Types</h2><p>Let’s consider what it would take to compose effects <code class="language-plaintext highlighter-rouge">State Int</code> and <code class="language-plaintext highlighter-rouge">State String</code> together. In the world of data types, we usually employ either products or coproducts to bridge two disjoint types together. Let’s try the latter and see where we end up:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kr">data</span> <span class="p">(</span><span class="n">f</span> <span class="o">:+:</span> <span class="n">g</span><span class="p">)</span> <span class="n">k</span> <span class="o">=</span> <span class="kt">L</span> <span class="p">(</span><span class="n">f</span> <span class="n">k</span><span class="p">)</span> <span class="o">|</span> <span class="kt">R</span> <span class="p">(</span><span class="n">g</span> <span class="n">k</span><span class="p">)</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">infixr</span> <span class="mi">4</span> <span class="o">:+:</span>
</pre></table></code></div></div><p>This allows us to join types in the following manner:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kt">L</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">5</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="o">:+:</span> <span class="kt">Identity</span><span class="p">)</span> <span class="kt">Int</span>
<span class="kt">L</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kt">R</span> <span class="p">(</span><span class="kt">Identity</span> <span class="mi">5</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="o">:+:</span> <span class="kt">Identity</span><span class="p">)</span> <span class="kt">Int</span>
<span class="kt">R</span> <span class="p">(</span><span class="kt">Identity</span> <span class="mi">5</span><span class="p">)</span>
</pre></table></code></div></div><p>We call this chain of functors a <strong>signature</strong>. We can compose a signature containing our <code class="language-plaintext highlighter-rouge">Int</code> and <code class="language-plaintext highlighter-rouge">String</code> state as well as a handler capable of interpreting it:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">runTwoState</span>
  <span class="o">::</span> <span class="n">forall</span> <span class="n">s1</span> <span class="n">s2</span> <span class="n">a</span>
   <span class="o">.</span> <span class="n">s1</span>
  <span class="o">-&gt;</span> <span class="n">s2</span>
  <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="p">(</span><span class="kt">State</span> <span class="n">s1</span> <span class="o">:+:</span> <span class="kt">State</span> <span class="n">s2</span><span class="p">)</span> <span class="n">a</span>
  <span class="o">-&gt;</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">runTwoState</span> <span class="n">s1</span> <span class="n">s2</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">L</span> <span class="p">(</span><span class="kt">Get</span> <span class="n">f</span><span class="p">)))</span>    <span class="o">=</span> <span class="n">runTwoState</span> <span class="n">s1</span> <span class="n">s2</span> <span class="p">(</span><span class="n">f</span> <span class="n">s1</span><span class="p">)</span>
<span class="n">runTwoState</span> <span class="n">s1</span> <span class="n">s2</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">R</span> <span class="p">(</span><span class="kt">Get</span> <span class="n">f</span><span class="p">)))</span>    <span class="o">=</span> <span class="n">runTwoState</span> <span class="n">s1</span> <span class="n">s2</span> <span class="p">(</span><span class="n">f</span> <span class="n">s2</span><span class="p">)</span>
<span class="n">runTwoState</span> <span class="kr">_</span>  <span class="n">s2</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">L</span> <span class="p">(</span><span class="kt">Put</span> <span class="n">s1</span> <span class="n">f</span><span class="p">)))</span> <span class="o">=</span> <span class="n">runTwoState</span> <span class="n">s1</span> <span class="n">s2</span> <span class="n">f</span>
<span class="n">runTwoState</span> <span class="n">s1</span> <span class="kr">_</span>  <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">R</span> <span class="p">(</span><span class="kt">Put</span> <span class="n">s2</span> <span class="n">f</span><span class="p">)))</span> <span class="o">=</span> <span class="n">runTwoState</span> <span class="n">s1</span> <span class="n">s2</span> <span class="n">f</span>
<span class="n">runTwoState</span> <span class="n">s1</span> <span class="n">s2</span> <span class="p">(</span><span class="kt">Pure</span> <span class="n">a</span><span class="p">)</span>              <span class="o">=</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</pre></table></code></div></div><p>It’s functional but hardly a solution. It requires manually writing every combination of effects introduced by <code class="language-plaintext highlighter-rouge">:+:</code> - a straight up herculean task as the signature gets longer. It also does not address the “expression problem”. That said, it <em>does</em> provide the scaffolding for a more polymorphic solution. We can bypass this combinatorial explosion of patterns by focusing on just one effect at a time, parameterizing the remainder of the signature. Handlers can then “peel” an effect off a signature, over and over, until we are out of effects to peel:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">runState'</span> <span class="o">::</span>
  <span class="n">forall</span> <span class="n">s</span> <span class="n">a</span> <span class="n">sig</span><span class="o">.</span>
  <span class="kt">Functor</span> <span class="n">sig</span> <span class="o">=&gt;</span>
  <span class="n">s</span> <span class="o">-&gt;</span>
  <span class="kt">Free</span> <span class="p">(</span><span class="kt">State</span> <span class="n">s</span> <span class="o">:+:</span> <span class="n">sig</span><span class="p">)</span> <span class="n">a</span> <span class="o">-&gt;</span>
  <span class="kt">Free</span> <span class="n">sig</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">runState'</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Pure</span> <span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">runState'</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">L</span> <span class="p">(</span><span class="kt">Get</span> <span class="n">f</span><span class="p">)))</span> <span class="o">=</span> <span class="n">runState'</span> <span class="n">s</span> <span class="p">(</span><span class="n">f</span> <span class="n">s</span><span class="p">)</span>
<span class="n">runState'</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">L</span> <span class="p">(</span><span class="kt">Put</span> <span class="n">s</span> <span class="n">f</span><span class="p">)))</span> <span class="o">=</span> <span class="n">runState'</span> <span class="n">s</span> <span class="n">f</span>
<span class="n">runState'</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">R</span> <span class="n">other</span><span class="p">))</span> <span class="o">=</span> <span class="kt">Free</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="n">runState'</span> <span class="n">s</span><span class="p">)</span> <span class="n">other</span><span class="p">)</span>
</pre></table></code></div></div><p>The above function combines the ideas of <code class="language-plaintext highlighter-rouge">runState</code> and <code class="language-plaintext highlighter-rouge">runTwoState</code> into a more general interface. Now programs containing <code class="language-plaintext highlighter-rouge">State</code> effects in any order can be interpreted by properly ordering the handlers:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="n">threadedState</span> <span class="o">::</span> <span class="kt">Free</span> <span class="p">(</span><span class="kt">State</span> <span class="kt">Int</span> <span class="o">:+:</span> <span class="kt">State</span> <span class="kt">String</span><span class="p">)</span> <span class="nb">()</span>
<span class="n">threadedState</span> <span class="o">=</span>
  <span class="kt">Free</span> <span class="p">(</span><span class="kt">L</span> <span class="p">(</span><span class="kt">Get</span> <span class="p">(</span><span class="nf">\</span><span class="n">s1</span> <span class="o">-&gt;</span>
    <span class="kt">Free</span> <span class="p">(</span><span class="kt">R</span> <span class="p">(</span><span class="kt">Get</span> <span class="p">(</span><span class="nf">\</span><span class="n">s2</span> <span class="o">-&gt;</span>
      <span class="kt">Free</span> <span class="p">(</span><span class="kt">L</span> <span class="p">(</span><span class="kt">Put</span> <span class="p">(</span><span class="n">s1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">R</span> <span class="p">(</span><span class="kt">Put</span> <span class="p">(</span><span class="n">s2</span> <span class="o">++</span> <span class="s">"a"</span><span class="p">)</span>
          <span class="p">(</span><span class="kt">Pure</span> <span class="nb">()</span><span class="p">))))))))))))</span>

<span class="n">threadedState'</span> <span class="o">::</span> <span class="kt">Free</span> <span class="p">(</span><span class="kt">State</span> <span class="kt">String</span> <span class="o">:+:</span> <span class="kt">State</span> <span class="kt">Int</span><span class="p">)</span> <span class="nb">()</span>
<span class="n">threadedState'</span> <span class="o">=</span> <span class="o">...</span>

<span class="c1">-- &gt;&gt;&gt; runState "" . runState' @Int 0 $ threadedState</span>
<span class="c1">-- ("a",(1,()))</span>
<span class="c1">-- &gt;&gt;&gt; runState @Int 0 . runState' "" $ threadedState'</span>
<span class="c1">-- (1,("a",()))</span>
</pre></table></code></div></div><h2 id="membership">Membership</h2><p>We can do better still. Our programs are far too concerned with the ordering of their corresponding signatures. The only thing they should care about is whether the effect exists at all. We can relax this coupling by introducing a new recursive typeclass:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kr">class</span> <span class="kt">Member</span> <span class="n">sub</span> <span class="n">sup</span> <span class="kr">where</span>
  <span class="n">inj</span> <span class="o">::</span> <span class="n">sub</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">sup</span> <span class="n">a</span>
  <span class="n">prj</span> <span class="o">::</span> <span class="n">sup</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="n">sub</span> <span class="n">a</span><span class="p">)</span>
</pre></table></code></div></div><p>Here <code class="language-plaintext highlighter-rouge">sub</code> is said to be a <em>subtype</em> of <code class="language-plaintext highlighter-rouge">sup</code>. <code class="language-plaintext highlighter-rouge">inj</code> allows us to promote that subtype to <code class="language-plaintext highlighter-rouge">sup</code> and <code class="language-plaintext highlighter-rouge">prj</code> allows us to dynamically downcast back to <code class="language-plaintext highlighter-rouge">sub</code>. This typeclass synergizes especially well with <code class="language-plaintext highlighter-rouge">:+:</code>. For instance, we expect <code class="language-plaintext highlighter-rouge">State Int</code> to be a subtype of <code class="language-plaintext highlighter-rouge">State Int :+: State String</code>. Importantly, we’d expect the same for <code class="language-plaintext highlighter-rouge">State String</code>. Let’s consider how instances of <code class="language-plaintext highlighter-rouge">Member</code> might look. First is reflexivity:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kr">instance</span> <span class="kt">Member</span> <span class="n">sig</span> <span class="n">sig</span> <span class="kr">where</span>
  <span class="n">inj</span> <span class="o">=</span> <span class="n">id</span>
  <span class="n">prj</span> <span class="o">=</span> <span class="kt">Just</span>
</pre></table></code></div></div><p>This instance should be fairly straightforward. We want to be able to cast a type to and from itself without issue. Next is left-occurrence:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kr">instance</span> <span class="kt">Member</span> <span class="n">sig</span> <span class="p">(</span><span class="n">sig</span> <span class="o">:+:</span> <span class="n">r</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">inj</span>       <span class="o">=</span> <span class="kt">L</span>
  <span class="n">prj</span> <span class="p">(</span><span class="kt">L</span> <span class="n">f</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Just</span> <span class="n">f</span>
  <span class="n">prj</span> <span class="kr">_</span>     <span class="o">=</span> <span class="kt">Nothing</span>
</pre></table></code></div></div><p>This is the pattern we’ve been working with up until now. Casting upwards is just a matter of using the <code class="language-plaintext highlighter-rouge">L</code> data constructor while projecting back down works so long as we are within the <code class="language-plaintext highlighter-rouge">L</code> context. Likewise there exists a right-recursion rule:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kr">instance</span> <span class="p">(</span><span class="kt">Member</span> <span class="n">sig</span> <span class="n">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Member</span> <span class="n">sig</span> <span class="p">(</span><span class="n">l</span> <span class="o">:+:</span> <span class="n">r</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">inj</span>       <span class="o">=</span> <span class="kt">R</span> <span class="o">.</span> <span class="n">inj</span>
  <span class="n">prj</span> <span class="p">(</span><span class="kt">R</span> <span class="n">g</span><span class="p">)</span> <span class="o">=</span> <span class="n">prj</span> <span class="n">g</span>
  <span class="n">prj</span> <span class="kr">_</span>     <span class="o">=</span> <span class="kt">Nothing</span>
</pre></table></code></div></div><p>Lastly, as a convenience, we introduce left-recursion:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kr">instance</span> <span class="kt">Member</span> <span class="n">sig</span> <span class="p">(</span><span class="n">l1</span> <span class="o">:+:</span> <span class="p">(</span><span class="n">l2</span> <span class="o">:+:</span> <span class="n">r</span><span class="p">))</span> <span class="o">=&gt;</span>
         <span class="kt">Member</span> <span class="n">sig</span> <span class="p">((</span><span class="n">l1</span> <span class="o">:+:</span> <span class="n">l2</span><span class="p">)</span> <span class="o">:+:</span> <span class="n">r</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">inj</span> <span class="n">sub</span> <span class="o">=</span> <span class="kr">case</span> <span class="n">inj</span> <span class="n">sub</span> <span class="kr">of</span>
    <span class="kt">L</span> <span class="n">l1</span>     <span class="o">-&gt;</span> <span class="kt">L</span> <span class="p">(</span><span class="kt">L</span> <span class="n">l1</span><span class="p">)</span>
    <span class="kt">R</span> <span class="p">(</span><span class="kt">L</span> <span class="n">l2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">L</span> <span class="p">(</span><span class="kt">R</span> <span class="n">l2</span><span class="p">)</span>
    <span class="kt">R</span> <span class="p">(</span><span class="kt">R</span> <span class="n">r</span><span class="p">)</span>  <span class="o">-&gt;</span> <span class="kt">R</span> <span class="n">r</span>
  <span class="n">prj</span> <span class="n">sup</span> <span class="o">=</span> <span class="kr">case</span> <span class="n">sup</span> <span class="kr">of</span>
    <span class="kt">L</span> <span class="p">(</span><span class="kt">L</span> <span class="n">l1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">prj</span> <span class="p">(</span><span class="kt">L</span> <span class="n">l1</span><span class="p">)</span>
    <span class="kt">L</span> <span class="p">(</span><span class="kt">R</span> <span class="n">l2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">prj</span> <span class="p">(</span><span class="kt">R</span> <span class="p">(</span><span class="kt">L</span> <span class="n">l2</span><span class="p">))</span>
    <span class="kt">R</span> <span class="n">r</span>      <span class="o">-&gt;</span> <span class="n">prj</span> <span class="p">(</span><span class="kt">R</span> <span class="p">(</span><span class="kt">R</span> <span class="n">r</span><span class="p">))</span>
</pre></table></code></div></div><p>The above allows us to operate on a <em>tree</em> of types rather than a list. We can read this as saying “subtying is not affected by how <code class="language-plaintext highlighter-rouge">:+:</code> is associated.”</p><div class="alert alert-warning" role="alert"><div><i class="fa fa-exclamation-triangle"></i> <strong>Warning</strong></div><p>These instances will not compile as is. A mix of <code class="language-plaintext highlighter-rouge">TypeApplications</code> and <code class="language-plaintext highlighter-rouge">OVERLAPPING</code> pragmas must be used. Refer to the <a href="https://github.com/jrpotter/effect-systems">git repository</a> for the real implementation.</p></div><p>With the above instances in place, we can now create a more flexible implementation of <code class="language-plaintext highlighter-rouge">threadedState</code> above:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kr">data</span> <span class="kt">Void</span> <span class="n">k</span> <span class="kr">deriving</span> <span class="kt">Functor</span>

<span class="n">run</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Free</span> <span class="kt">Void</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">run</span> <span class="p">(</span><span class="kt">Pure</span> <span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>
<span class="n">run</span> <span class="kr">_</span> <span class="o">=</span> <span class="n">error</span> <span class="p">(</span><span class="n">pack</span> <span class="s">"impossible"</span><span class="p">)</span>

<span class="n">threadedState''</span> <span class="o">::</span>
  <span class="kt">Functor</span> <span class="n">sig</span> <span class="o">=&gt;</span>
  <span class="kt">Member</span> <span class="p">(</span><span class="kt">State</span> <span class="kt">Int</span><span class="p">)</span> <span class="n">sig</span> <span class="o">=&gt;</span>
  <span class="kt">Member</span> <span class="p">(</span><span class="kt">State</span> <span class="kt">String</span><span class="p">)</span> <span class="n">sig</span> <span class="o">=&gt;</span>
  <span class="kt">Free</span> <span class="n">sig</span> <span class="nb">()</span>
<span class="n">threadedState''</span> <span class="o">=</span>
  <span class="kt">Free</span> <span class="p">(</span><span class="n">inj</span> <span class="p">(</span><span class="kt">Get</span> <span class="o">@</span><span class="kt">Int</span> <span class="p">(</span><span class="nf">\</span><span class="n">s1</span> <span class="o">-&gt;</span>
    <span class="kt">Free</span> <span class="p">(</span><span class="n">inj</span> <span class="p">(</span><span class="kt">Get</span> <span class="p">(</span><span class="nf">\</span><span class="n">s2</span> <span class="o">-&gt;</span>
      <span class="kt">Free</span> <span class="p">(</span><span class="n">inj</span> <span class="p">(</span><span class="kt">Put</span> <span class="p">(</span><span class="n">s1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="n">inj</span> <span class="p">(</span><span class="kt">Put</span> <span class="p">(</span><span class="n">s2</span> <span class="o">++</span> <span class="s">"a"</span><span class="p">)</span>
          <span class="p">(</span><span class="kt">Pure</span> <span class="nb">()</span><span class="p">))))))))))))</span>

<span class="c1">-- &gt;&gt;&gt; run . runState' "" . runState' @Int 0 $ threadedState''</span>
<span class="c1">-- ("a",(1,()))</span>
<span class="c1">-- &gt;&gt;&gt; run . runState' @Int 0 . runState' "" $ threadedState''</span>
<span class="c1">-- (1,("a",()))</span>
</pre></table></code></div></div><p>A few takeaways:</p><ol><li>The program now stays polymorphic in type <code class="language-plaintext highlighter-rouge">sig</code>,<li>We no longer explicitly mention <code class="language-plaintext highlighter-rouge">L</code> or <code class="language-plaintext highlighter-rouge">R</code> data constructors, and<li>We use <code class="language-plaintext highlighter-rouge">run</code> to peel away the final effect.</ol><p>This flexibility grants us the ability to <em>choose</em> the order we handle effects at the call site. By writing a few additional smart constructors, we could have a nicer program still:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="n">inject</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Member</span> <span class="n">sub</span> <span class="n">sup</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">sub</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">sup</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">sup</span> <span class="n">a</span>
<span class="n">inject</span> <span class="o">=</span> <span class="kt">Free</span> <span class="o">.</span> <span class="n">inj</span>

<span class="n">project</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Member</span> <span class="n">sub</span> <span class="n">sup</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Free</span> <span class="n">sup</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="n">sub</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">sup</span> <span class="n">a</span><span class="p">))</span>
<span class="n">project</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">prj</span> <span class="n">s</span>
<span class="n">project</span> <span class="kr">_</span>        <span class="o">=</span> <span class="kt">Nothing</span>

<span class="n">get</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">sig</span> <span class="o">=&gt;</span> <span class="kt">Member</span> <span class="p">(</span><span class="kt">State</span> <span class="n">s</span><span class="p">)</span> <span class="n">sig</span> <span class="o">=&gt;</span> <span class="kt">Free</span> <span class="n">sig</span> <span class="n">s</span>
<span class="n">get</span> <span class="o">=</span> <span class="n">inject</span> <span class="p">(</span><span class="kt">Get</span> <span class="n">pure</span><span class="p">)</span>

<span class="n">put</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">sig</span> <span class="o">=&gt;</span> <span class="kt">Member</span> <span class="p">(</span><span class="kt">State</span> <span class="n">s</span><span class="p">)</span> <span class="n">sig</span> <span class="o">=&gt;</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">sig</span> <span class="nb">()</span>
<span class="n">put</span> <span class="n">s</span> <span class="o">=</span> <span class="n">inject</span> <span class="p">(</span><span class="kt">Put</span> <span class="n">s</span> <span class="p">(</span><span class="n">pure</span> <span class="nb">()</span><span class="p">))</span>

<span class="n">threadedStateM''</span> <span class="o">::</span>
  <span class="kt">Functor</span> <span class="n">sig</span> <span class="o">=&gt;</span>
  <span class="kt">Member</span> <span class="p">(</span><span class="kt">State</span> <span class="kt">Int</span><span class="p">)</span> <span class="n">sig</span> <span class="o">=&gt;</span>
  <span class="kt">Member</span> <span class="p">(</span><span class="kt">State</span> <span class="kt">String</span><span class="p">)</span> <span class="n">sig</span> <span class="o">=&gt;</span>
  <span class="kt">Free</span> <span class="n">sig</span> <span class="nb">()</span>
<span class="n">threadedStateM''</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">s1</span> <span class="o">&lt;-</span> <span class="n">get</span> <span class="o">@</span><span class="kt">Int</span>
  <span class="n">s2</span> <span class="o">&lt;-</span> <span class="n">get</span> <span class="o">@</span><span class="kt">String</span>
  <span class="n">put</span> <span class="p">(</span><span class="n">s1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">put</span> <span class="p">(</span><span class="n">s2</span> <span class="o">++</span> <span class="s">"a"</span><span class="p">)</span>
  <span class="n">pure</span> <span class="nb">()</span>
</pre></table></code></div></div><h1 id="higher-order-effects">Higher-Order Effects</h1><p>This composition provides many benefits, but in certain situations we end up hitting a wall. To continue forward, we borrow an example from <a href="https://www.cs.ox.ac.uk/people/nicolas.wu/papers/Scope.pdf">Effect Handlers in Scope</a>. In particular, we discuss exception handling and how we can use a free monad to simulate throwing and catching exceptions.</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kr">newtype</span> <span class="kt">Throw</span> <span class="n">e</span> <span class="n">k</span> <span class="o">=</span> <span class="kt">Throw</span> <span class="n">e</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">)</span>

<span class="n">throw</span> <span class="n">e</span> <span class="o">=</span> <span class="n">inject</span> <span class="p">(</span><span class="kt">Throw</span> <span class="n">e</span><span class="p">)</span>
</pre></table></code></div></div><div class="alert alert-info" role="alert"><div><i class="fa fa-info-circle"></i> <strong>Info</strong></div><p>To avoid too many distractions, we will sometimes skip writing type signatures.</p></div><p>This <code class="language-plaintext highlighter-rouge">Throw</code> type should feel very intuitive at this point. We take an exception and “inject” it into our program using the <code class="language-plaintext highlighter-rouge">throw</code> smart constructor. What’s the <code class="language-plaintext highlighter-rouge">catch</code>?</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">catch</span> <span class="p">(</span><span class="kt">Pure</span> <span class="n">a</span><span class="p">)</span>             <span class="kr">_</span> <span class="o">=</span> <span class="n">pure</span> <span class="n">a</span>
<span class="n">catch</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">L</span> <span class="p">(</span><span class="kt">Throw</span> <span class="n">e</span><span class="p">)))</span> <span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="n">e</span>
<span class="n">catch</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">R</span> <span class="n">other</span><span class="p">))</span>     <span class="n">h</span> <span class="o">=</span> <span class="kt">Free</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(`</span><span class="n">catch</span><span class="p">`</span> <span class="n">h</span><span class="p">)</span> <span class="n">other</span><span class="p">)</span>
</pre></table></code></div></div><p>In this scenario, <code class="language-plaintext highlighter-rouge">catch</code> traverses our program, happily passing values through until it encounters a <code class="language-plaintext highlighter-rouge">Throw</code>. Our respective “peel” looks like so:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">runThrow</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">e</span> <span class="n">a</span> <span class="n">sig</span><span class="o">.</span> <span class="kt">Free</span> <span class="p">(</span><span class="kt">Throw</span> <span class="n">e</span> <span class="o">:+:</span> <span class="n">sig</span><span class="p">)</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">sig</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span> <span class="n">a</span><span class="p">)</span>
<span class="n">runThrow</span> <span class="p">(</span><span class="kt">Pure</span> <span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">a</span><span class="p">)</span>
<span class="n">runThrow</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">L</span> <span class="p">(</span><span class="kt">Throw</span> <span class="n">e</span><span class="p">)))</span> <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">e</span><span class="p">)</span>
<span class="n">runThrow</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">R</span> <span class="n">other</span><span class="p">))</span> <span class="o">=</span> <span class="kt">Free</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">runThrow</span> <span class="n">other</span><span class="p">)</span>
</pre></table></code></div></div><p>We now have the requisite tools needed to build up and execute a sample program that composes some <code class="language-plaintext highlighter-rouge">State Int</code> effect with a <code class="language-plaintext highlighter-rouge">Throw</code> effect:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">countDown</span> <span class="o">::</span>
  <span class="n">forall</span> <span class="n">sig</span><span class="o">.</span>
  <span class="kt">Functor</span> <span class="n">sig</span> <span class="o">=&gt;</span>
  <span class="kt">Member</span> <span class="p">(</span><span class="kt">State</span> <span class="kt">Int</span><span class="p">)</span> <span class="n">sig</span> <span class="o">=&gt;</span>
  <span class="kt">Member</span> <span class="p">(</span><span class="kt">Throw</span> <span class="nb">()</span><span class="p">)</span> <span class="n">sig</span> <span class="o">=&gt;</span>
  <span class="kt">Free</span> <span class="n">sig</span> <span class="nb">()</span>
<span class="n">countDown</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">decr</span> <span class="cm">{- 1 -}</span>
  <span class="n">catch</span> <span class="p">(</span><span class="n">decr</span> <span class="cm">{- 2 -}</span> <span class="o">&gt;&gt;</span> <span class="n">decr</span> <span class="cm">{- 3 -}</span><span class="p">)</span> <span class="n">pure</span>
 <span class="kr">where</span>
  <span class="n">decr</span> <span class="o">=</span> <span class="kr">do</span>
    <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">get</span> <span class="o">@</span><span class="kt">Int</span>
    <span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="kr">then</span> <span class="n">put</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="kr">else</span> <span class="n">throw</span> <span class="nb">()</span>
</pre></table></code></div></div><p>This program calls a potentially dangerous <code class="language-plaintext highlighter-rouge">decr</code> function three times, with the last two attempts wrapped around a <code class="language-plaintext highlighter-rouge">catch</code>.</p><h2 id="scoping-problems">Scoping Problems</h2><p>How should the state of <code class="language-plaintext highlighter-rouge">countDown</code> be interpreted? There exist two reasonable options:</p><ol><li>If state is considered <strong>global</strong>, then successful decrements in catch should persist. That is, our final state would be the initial value decremented as many times as <code class="language-plaintext highlighter-rouge">decr</code> succeeds.<li>If state is considered <strong>local</strong>, we expect <code class="language-plaintext highlighter-rouge">catch</code> to decrement state twice but to <em>rollback</em> if an error is raised. If an error is caught, our final state would be the initial value decremented just the once.</ol><p>This is what it means for an operation to be <strong>scoped</strong>. In the local case, within the semantics of exception handling, the nested program within <code class="language-plaintext highlighter-rouge">catch</code> should not affect the state of the world outside of it in the case of an exception. Let’s see if we can somehow write and invoke handlers accordingly:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">run</span> <span class="o">.</span> <span class="n">runThrow</span> <span class="o">@</span><span class="nb">()</span> <span class="o">.</span> <span class="n">runState'</span> <span class="o">@</span><span class="kt">Int</span> <span class="mi">3</span> <span class="o">$</span> <span class="n">countDown</span>
<span class="kt">Right</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">()</span><span class="p">)</span>
</pre></table></code></div></div><p>The above snippet demonstrates a result we expect in either interpretation. The nested <code class="language-plaintext highlighter-rouge">decr &gt;&gt; decr</code> raises no error. Likewise</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">run</span> <span class="o">.</span> <span class="n">runThrow</span> <span class="o">@</span><span class="nb">()</span> <span class="o">.</span> <span class="n">runState'</span> <span class="o">@</span><span class="kt">Int</span> <span class="mi">0</span> <span class="o">$</span> <span class="n">countDown</span>
<span class="kt">Left</span> <span class="nb">()</span>
</pre></table></code></div></div><p>should also feel correct, regardless of interpretation. <code class="language-plaintext highlighter-rouge">decr {- 1 -}</code> ends up returning a <code class="language-plaintext highlighter-rouge">throw ()</code> which the subsequent <code class="language-plaintext highlighter-rouge">runThrow</code> handler interprets as <code class="language-plaintext highlighter-rouge">Left</code>. What about the following?</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">run</span> <span class="o">.</span> <span class="n">runThrow</span> <span class="o">@</span><span class="nb">()</span> <span class="o">.</span> <span class="n">runState'</span> <span class="o">@</span><span class="kt">Int</span> <span class="mi">2</span> <span class="o">$</span> <span class="n">countDown</span>
<span class="kt">Right</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">()</span><span class="p">)</span>
</pre></table></code></div></div><p>This is an example of a global interpretation. Here we throw an error on <code class="language-plaintext highlighter-rouge">decr {- 3 -}</code> but <code class="language-plaintext highlighter-rouge">decr {- 2 -}</code>’s effects persist despite existing within the <code class="language-plaintext highlighter-rouge">catch</code>. So can we scope the operation? As it turns out, local semantics are out of reach. “Flattening” the program hopefully makes the reason clearer:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">countDown'</span> <span class="o">=</span>
  <span class="kt">Free</span> <span class="p">(</span><span class="n">inj</span> <span class="p">(</span><span class="kt">Get</span> <span class="o">@</span><span class="kt">Int</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span>
    <span class="kr">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nf">\</span><span class="n">k</span> <span class="o">-&gt;</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="kr">then</span> <span class="kt">Free</span> <span class="p">(</span><span class="n">inj</span> <span class="p">(</span><span class="kt">Put</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="n">k</span><span class="p">))</span> <span class="kr">else</span> <span class="n">throw</span> <span class="nb">()</span>
     <span class="kr">in</span> <span class="n">a</span> <span class="p">(</span><span class="n">catch</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="n">inj</span> <span class="p">(</span><span class="kt">Get</span> <span class="o">@</span><span class="kt">Int</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span>
      <span class="kr">let</span> <span class="n">b</span> <span class="o">=</span> <span class="nf">\</span><span class="n">k</span> <span class="o">-&gt;</span> <span class="kr">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="kr">then</span> <span class="kt">Free</span> <span class="p">(</span><span class="n">inj</span> <span class="p">(</span><span class="kt">Put</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="n">k</span><span class="p">))</span> <span class="kr">else</span> <span class="n">throw</span> <span class="nb">()</span>
       <span class="kr">in</span> <span class="n">b</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="n">inj</span> <span class="p">(</span><span class="kt">Get</span> <span class="o">@</span><span class="kt">Int</span> <span class="p">(</span><span class="nf">\</span><span class="n">z</span> <span class="o">-&gt;</span>
         <span class="kr">let</span> <span class="n">c</span> <span class="o">=</span> <span class="nf">\</span><span class="n">k</span> <span class="o">-&gt;</span> <span class="kr">if</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="kr">then</span> <span class="kt">Free</span> <span class="p">(</span><span class="n">inj</span> <span class="p">(</span><span class="kt">Put</span> <span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="n">k</span><span class="p">))</span> <span class="kr">else</span> <span class="n">throw</span> <span class="nb">()</span>
          <span class="kr">in</span> <span class="n">c</span> <span class="p">(</span><span class="kt">Pure</span> <span class="nb">()</span><span class="p">)))))))))</span> <span class="n">pure</span><span class="p">))))</span>
</pre></table></code></div></div><p>It’s noisy, but in the above snippet we see there exists no mechanism that “saves” the state prior to running the nested program.</p><h2 id="a-stronger-free">A Stronger Free</h2><p>Somehow we need to ensure a nested (e.g. the program scoped within <code class="language-plaintext highlighter-rouge">catch</code>) does not “leak” in any way. To support programs within programs (within programs within programs…) within the already recursively defined free monad, we look towards a higher-level abstraction for help. According to Wu, Schrijvers, and Hinze,</p><blockquote><p>A more direct solution [to handle some self-contained context] is to model scoping constructs with higher-order syntax, where the syntax carries those syntax blocks directly.</p></blockquote><p>What would such a change look like? To answer that, it proves illustrative understanding why our current definition of <code class="language-plaintext highlighter-rouge">Free</code> is insufficient. Consider what it means to “run” our program. We have a handler that traverses the program, operates on effects it knows how to operate on, and then returns a slightly less abstract program for the next handler to process. To save state, we somehow need each handler to refer to a <strong>context</strong> containing state as defined by the handler prior.</p><p>As a starting point, review our current definition of <code class="language-plaintext highlighter-rouge">Free</code>:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kr">data</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Pure</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Free</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">f</span> <span class="n">a</span><span class="p">))</span>
</pre></table></code></div></div><p>We see <code class="language-plaintext highlighter-rouge">a</code> is not something we, the effects library author, are in a position to manipulate. To actually extract a value to be saved and threaded in a context though, we at the very least need this ability. So can we introduce some change that give us this freedom? One idea is:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kr">data</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Pure</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Free</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">f</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span>
</pre></table></code></div></div><p>The change is subtle but has potential provided we can get all the derived type machinery working on this type instead. Take note! Previously the kind of <code class="language-plaintext highlighter-rouge">f</code> was <code class="language-plaintext highlighter-rouge">Type -&gt; Type</code>. In this new definition, we see it is now <code class="language-plaintext highlighter-rouge">(Type -&gt; Type) -&gt; (Type -&gt; Type)</code>. That is, <code class="language-plaintext highlighter-rouge">f</code> is now a function that maps one type function to another. We have entered the world of higher-order kinds.</p><div class="alert alert-info" role="alert"><div><i class="fa fa-info-circle"></i> <strong>Info</strong></div><p><code class="language-plaintext highlighter-rouge">f</code> is usually a natural transformation, mapping one functor to another. The specifics regarding natural transformations aren’t too important here. Just note when we use the term going forward, we mean a functor to functor mapping.</p></div><p>Ideally we can extrapolate our learnings so far to this higher-order world. Of most importance is our <code class="language-plaintext highlighter-rouge">Functor</code>-constrained type variable <code class="language-plaintext highlighter-rouge">f</code>. Let’s dive a bit deeper into what it currently buys us. First, take another look at how <code class="language-plaintext highlighter-rouge">fmap</code> is used within <code class="language-plaintext highlighter-rouge">Free</code>’s <code class="language-plaintext highlighter-rouge">Monad</code> instance:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kr">instance</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">Pure</span> <span class="n">a</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span> <span class="n">a</span>
  <span class="kt">Free</span> <span class="n">f</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span> <span class="o">=</span> <span class="kt">Free</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="o">&gt;&gt;=</span> <span class="n">g</span><span class="p">)</span> <span class="n">f</span><span class="p">)</span>
</pre></table></code></div></div><p>Its purpose is to allow <em>extending</em> our syntax, chaining different DSL terms together into a bigger program. When we write e.g.</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">readThenWrite</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">input</span> <span class="o">&lt;-</span> <span class="n">read</span>
  <span class="n">write</span> <span class="n">input</span>
</pre></table></code></div></div><p>it is <code class="language-plaintext highlighter-rouge">fmap</code> that is responsible for piecing the <code class="language-plaintext highlighter-rouge">read</code> and <code class="language-plaintext highlighter-rouge">write</code> together. Second, re-examine a sample handler, e.g.</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">runState'</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Pure</span> <span class="n">a</span><span class="p">)</span>             <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">runState'</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">L</span> <span class="p">(</span><span class="kt">Get</span> <span class="n">f</span><span class="p">)))</span>   <span class="o">=</span> <span class="n">runState'</span> <span class="n">s</span> <span class="p">(</span><span class="n">f</span> <span class="n">s</span><span class="p">)</span>
<span class="n">runState'</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">L</span> <span class="p">(</span><span class="kt">Put</span> <span class="n">s</span> <span class="n">f</span><span class="p">)))</span> <span class="o">=</span> <span class="n">runState'</span> <span class="n">s</span> <span class="n">f</span>
<span class="n">runState'</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">R</span> <span class="n">other</span><span class="p">))</span>     <span class="o">=</span> <span class="kt">Free</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="n">runState'</span> <span class="n">s</span><span class="p">)</span> <span class="n">other</span><span class="p">)</span>
</pre></table></code></div></div><p>In this case, <code class="language-plaintext highlighter-rouge">fmap</code> is responsible for <em>weaving</em> the state semantics throughout the syntax. This is what allows us to interpret programs comprised of multiple different syntaxes. Whatever we end up building at the higher level needs to keep both these aspects in mind.</p><h3 id="higher-order-syntax">Higher-Order Syntax</h3><p>Syntax is the easier of the two to resolve so that’s where we’ll first avert out attention. Extension requires two things:</p><ol><li>A higher-level concept of a functor to constrain our new <code class="language-plaintext highlighter-rouge">f</code>, and<li>An <code class="language-plaintext highlighter-rouge">fmap</code>-like function capable of performing the extension.</ol><p>Building out (1) is fairly straightforward. Since <code class="language-plaintext highlighter-rouge">f</code> corresponds to a natural transformation, we create a mapping between functors like so:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kr">class</span> <span class="kt">HFunctor</span> <span class="n">f</span> <span class="kr">where</span>
  <span class="n">hmap</span> <span class="o">::</span>
    <span class="p">(</span><span class="kt">Functor</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Functor</span> <span class="n">n</span><span class="p">)</span> <span class="o">=&gt;</span>
    <span class="p">(</span><span class="n">forall</span> <span class="n">x</span><span class="o">.</span> <span class="n">m</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">(</span><span class="n">forall</span> <span class="n">x</span><span class="o">.</span> <span class="n">f</span> <span class="n">m</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">n</span> <span class="n">x</span><span class="p">)</span>
</pre></table></code></div></div><p>This allows us to lift transformations of e.g. <code class="language-plaintext highlighter-rouge">Identity -&gt; Maybe</code> into <code class="language-plaintext highlighter-rouge">f Identity -&gt; f Maybe</code>. Take a moment to notice the parallels between <code class="language-plaintext highlighter-rouge">fmap</code> and <code class="language-plaintext highlighter-rouge">hmap</code>. Building (2) is equally simple:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kr">class</span> <span class="kt">HFunctor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="kt">Syntax</span> <span class="n">f</span> <span class="kr">where</span>
  <span class="n">emap</span> <span class="o">::</span> <span class="p">(</span><span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span>
</pre></table></code></div></div><p>We designate <code class="language-plaintext highlighter-rouge">emap</code> as our <code class="language-plaintext highlighter-rouge">fmap</code>-extending equivalent. This is made obvious by seeing how <code class="language-plaintext highlighter-rouge">Free</code> ends up using <code class="language-plaintext highlighter-rouge">emap</code>:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kr">instance</span> <span class="kt">Syntax</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">Pure</span> <span class="n">a</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span> <span class="n">a</span>
  <span class="kt">Free</span> <span class="n">f</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span> <span class="o">=</span> <span class="kt">Free</span> <span class="p">(</span><span class="n">emap</span> <span class="p">(</span><span class="o">&gt;&gt;=</span> <span class="n">g</span><span class="p">)</span> <span class="n">f</span><span class="p">)</span>
</pre></table></code></div></div><p>Once again, note the parallels betwen the <code class="language-plaintext highlighter-rouge">Monad</code> instances of both <code class="language-plaintext highlighter-rouge">Free</code>s.</p><h3 id="higher-order-semantics">Higher-Order Semantics</h3><p>The more difficult problem lies on the semantic side of the equation. This part needs to manage the threading of functions throughout potentially nested effects. To demonstrate, consider a revision to our <code class="language-plaintext highlighter-rouge">Throw</code> type that includes a <code class="language-plaintext highlighter-rouge">Catch</code> at the syntactic level:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kr">data</span> <span class="kt">Error</span> <span class="n">e</span> <span class="n">m</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Throw</span> <span class="n">e</span>
                 <span class="o">|</span> <span class="n">forall</span> <span class="n">x</span><span class="o">.</span> <span class="kt">Catch</span> <span class="p">(</span><span class="n">m</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span><span class="p">)</span>
</pre></table></code></div></div><p>We can create <code class="language-plaintext highlighter-rouge">Error</code> instances of our <code class="language-plaintext highlighter-rouge">HFunctor</code> and <code class="language-plaintext highlighter-rouge">Syntax</code> classes as follows:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kr">instance</span> <span class="kt">HFunctor</span> <span class="p">(</span><span class="kt">Error</span> <span class="n">e</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">hmap</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Throw</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Throw</span> <span class="n">x</span>
  <span class="n">hmap</span> <span class="n">t</span> <span class="p">(</span><span class="kt">Catch</span> <span class="n">p</span> <span class="n">h</span> <span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Catch</span> <span class="p">(</span><span class="n">t</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">t</span> <span class="o">.</span> <span class="n">h</span><span class="p">)</span> <span class="p">(</span><span class="n">t</span> <span class="o">.</span> <span class="n">k</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Syntax</span> <span class="p">(</span><span class="kt">Error</span> <span class="n">e</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">emap</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Throw</span> <span class="n">e</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Throw</span> <span class="n">e</span>
  <span class="n">emap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Catch</span> <span class="n">p</span> <span class="n">h</span> <span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Catch</span> <span class="n">p</span> <span class="n">h</span> <span class="p">(</span><span class="n">f</span> <span class="o">.</span> <span class="n">k</span><span class="p">)</span>
</pre></table></code></div></div><p>This is all well and good, but now suppose we want to write a handler in the same way we wrote <code class="language-plaintext highlighter-rouge">runThrow</code> earlier:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="n">runError</span> <span class="o">::</span>
  <span class="n">forall</span> <span class="n">e</span> <span class="n">a</span> <span class="n">sig</span><span class="o">.</span>
  <span class="kt">Syntax</span> <span class="n">sig</span> <span class="o">=&gt;</span>
  <span class="kt">Free</span> <span class="p">(</span><span class="kt">Error</span> <span class="n">e</span> <span class="o">:+:</span> <span class="n">sig</span><span class="p">)</span> <span class="n">a</span> <span class="o">-&gt;</span>
  <span class="kt">Free</span> <span class="n">sig</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span> <span class="n">a</span><span class="p">)</span>
<span class="n">runError</span> <span class="p">(</span><span class="kt">Pure</span> <span class="n">a</span><span class="p">)</span>                 <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">a</span><span class="p">)</span>
<span class="n">runError</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">L</span> <span class="p">(</span><span class="kt">Throw</span> <span class="n">e</span><span class="p">)))</span>     <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">e</span><span class="p">)</span>
<span class="n">runError</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">L</span> <span class="p">(</span><span class="kt">Catch</span> <span class="n">p</span> <span class="n">h</span> <span class="n">k</span><span class="p">)))</span> <span class="o">=</span>
  <span class="n">runError</span> <span class="n">p</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="kr">case</span>
    <span class="kt">Left</span> <span class="n">e</span> <span class="o">-&gt;</span>
      <span class="n">runError</span> <span class="p">(</span><span class="n">h</span> <span class="n">e</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="kr">case</span>
        <span class="kt">Left</span> <span class="n">e'</span> <span class="o">-&gt;</span> <span class="n">pure</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">e'</span><span class="p">)</span>
        <span class="kt">Right</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">runError</span> <span class="p">(</span><span class="n">k</span> <span class="n">a</span><span class="p">)</span>
    <span class="kt">Right</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">runError</span> <span class="p">(</span><span class="n">k</span> <span class="n">a</span><span class="p">)</span>
<span class="n">runError</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">R</span> <span class="n">other</span><span class="p">))</span>         <span class="o">=</span> <span class="kt">Free</span> <span class="kr">_</span>
</pre></table></code></div></div><p>Make sure everything leading up to the last pattern makes sense and then ask yourself how you might fill in the hole (<code class="language-plaintext highlighter-rouge">_</code>). We only have a few tools at our disposal, namely <code class="language-plaintext highlighter-rouge">hmap</code> and <code class="language-plaintext highlighter-rouge">emap</code>. But, no matter how we choose to compose them, <code class="language-plaintext highlighter-rouge">hmap</code> will let us down. In particular, our only means of “peeling” the signature is <code class="language-plaintext highlighter-rouge">runError</code> which is incompatible with the natural transformation <code class="language-plaintext highlighter-rouge">hmap</code> expects.</p><hr /><p>We need another function specific for this weaving behavior, which we choose to add to the <code class="language-plaintext highlighter-rouge">Syntax</code> typeclass:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kr">class</span> <span class="kt">HFunctor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="kt">Syntax</span> <span class="n">f</span> <span class="kr">where</span>
  <span class="n">emap</span> <span class="o">::</span> <span class="p">(</span><span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span>

  <span class="n">weave</span> <span class="o">::</span>
    <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Monad</span> <span class="n">n</span><span class="p">,</span> <span class="kt">Functor</span> <span class="n">ctx</span><span class="p">)</span> <span class="o">=&gt;</span>
    <span class="n">ctx</span> <span class="nb">()</span> <span class="o">-&gt;</span>
    <span class="kt">Handler</span> <span class="n">ctx</span> <span class="n">m</span> <span class="n">n</span> <span class="o">-&gt;</span>
    <span class="p">(</span><span class="n">f</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">n</span> <span class="p">(</span><span class="n">ctx</span> <span class="n">a</span><span class="p">))</span>

<span class="kr">type</span> <span class="kt">Handler</span> <span class="n">ctx</span> <span class="n">m</span> <span class="n">n</span> <span class="o">=</span> <span class="n">forall</span> <span class="n">x</span><span class="o">.</span> <span class="n">ctx</span> <span class="p">(</span><span class="n">m</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="p">(</span><span class="n">ctx</span> <span class="n">x</span><span class="p">)</span>
</pre></table></code></div></div><p>Pay special attention to <code class="language-plaintext highlighter-rouge">Handler</code>. By introducing a functorial context (i.e. <code class="language-plaintext highlighter-rouge">ctx</code>), we have defined a function signature that more closely reflects that of <code class="language-plaintext highlighter-rouge">runError</code>. This is made clearer by instantiating <code class="language-plaintext highlighter-rouge">ctx</code> to <code class="language-plaintext highlighter-rouge">Either e</code>:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kr">type</span> <span class="kt">Handler</span> <span class="n">m</span> <span class="n">n</span> <span class="o">=</span> <span class="n">forall</span> <span class="n">x</span><span class="o">.</span> <span class="kt">Either</span> <span class="n">e</span> <span class="p">(</span><span class="n">m</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span> <span class="n">x</span><span class="p">)</span>

<span class="n">runError</span> <span class="o">::</span> <span class="kt">Free</span> <span class="p">(</span><span class="kt">Error</span> <span class="n">e</span> <span class="o">:+:</span> <span class="n">sig</span><span class="p">)</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">sig</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span> <span class="n">a</span><span class="p">)</span>
</pre></table></code></div></div><p>Without <code class="language-plaintext highlighter-rouge">ctx</code>, <code class="language-plaintext highlighter-rouge">weave</code> would look just like <code class="language-plaintext highlighter-rouge">hmap</code>, highlighting how it’s particularly well-suited to bypassing the <code class="language-plaintext highlighter-rouge">hmap</code>’s limitations. With <code class="language-plaintext highlighter-rouge">weave</code> also comes expanded <code class="language-plaintext highlighter-rouge">Syntax</code> instances:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kr">instance</span> <span class="p">(</span><span class="kt">Syntax</span> <span class="n">f</span><span class="p">,</span> <span class="kt">Syntax</span> <span class="n">g</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Syntax</span> <span class="p">(</span><span class="n">f</span> <span class="o">:+:</span> <span class="n">g</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">weave</span> <span class="n">ctx</span> <span class="n">hdl</span> <span class="p">(</span><span class="kt">L</span> <span class="n">f</span><span class="p">)</span> <span class="o">=</span> <span class="kt">L</span> <span class="p">(</span><span class="n">weave</span> <span class="n">ctx</span> <span class="n">hdl</span> <span class="n">f</span><span class="p">)</span>
  <span class="n">weave</span> <span class="n">ctx</span> <span class="n">hdl</span> <span class="p">(</span><span class="kt">R</span> <span class="n">g</span><span class="p">)</span> <span class="o">=</span> <span class="kt">R</span> <span class="p">(</span><span class="n">weave</span> <span class="n">ctx</span> <span class="n">hdl</span> <span class="n">g</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Syntax</span> <span class="p">(</span><span class="kt">Error</span> <span class="n">e</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">weave</span> <span class="kr">_</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Throw</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Throw</span> <span class="n">x</span>
  <span class="n">weave</span> <span class="n">ctx</span> <span class="n">hdl</span> <span class="p">(</span><span class="kt">Catch</span> <span class="n">p</span> <span class="n">h</span> <span class="n">k</span><span class="p">)</span> <span class="o">=</span>
    <span class="c1">-- forall x. Catch (m x) (e -&gt; m x) (x -&gt; m a)</span>
    <span class="kt">Catch</span>
      <span class="p">(</span><span class="n">hdl</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="n">const</span> <span class="n">p</span><span class="p">)</span> <span class="n">ctx</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">\</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">hdl</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="n">const</span> <span class="p">(</span><span class="n">h</span> <span class="n">e</span><span class="p">))</span> <span class="n">ctx</span><span class="p">))</span>
      <span class="p">(</span><span class="n">hdl</span> <span class="o">.</span> <span class="n">fmap</span> <span class="n">k</span><span class="p">)</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">const</code> is used solely to wrap our results in a way that <code class="language-plaintext highlighter-rouge">hdl</code> expects. With these instances fully defined, we can now finish our <code class="language-plaintext highlighter-rouge">runError</code> handler:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">runError</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">R</span> <span class="n">other</span><span class="p">))</span> <span class="o">=</span>
  <span class="kt">Free</span> <span class="o">$</span> <span class="n">weave</span> <span class="p">(</span><span class="kt">Right</span> <span class="nb">()</span><span class="p">)</span> <span class="p">(</span><span class="n">either</span> <span class="p">(</span><span class="n">pure</span> <span class="o">.</span> <span class="kt">Left</span><span class="p">)</span> <span class="n">runError</span><span class="p">)</span> <span class="n">other</span>
</pre></table></code></div></div><h3 id="lifting">Lifting</h3><p>The solution we’ve developed so far wouldn’t be especially useful if it was weaker than the previous. As mentioned before, our new solution splits the functionality of <code class="language-plaintext highlighter-rouge">fmap</code> into extension and weaving. But nothing is stopping us from defining an instance that continues using <code class="language-plaintext highlighter-rouge">fmap</code> for both. Consider the following:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kr">newtype</span> <span class="kt">Lift</span> <span class="n">sig</span> <span class="p">(</span><span class="n">m</span> <span class="o">::</span> <span class="kt">Type</span> <span class="o">-&gt;</span> <span class="kt">Type</span><span class="p">)</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Lift</span> <span class="p">(</span><span class="n">sig</span> <span class="p">(</span><span class="n">m</span> <span class="n">a</span><span class="p">))</span>
</pre></table></code></div></div><p>Here <code class="language-plaintext highlighter-rouge">sig</code> refers to the lower-order data type we want to elevate to our higher-order <code class="language-plaintext highlighter-rouge">Free</code>, e.g. <code class="language-plaintext highlighter-rouge">State s</code>:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kr">type</span> <span class="kt">HState</span> <span class="n">s</span> <span class="o">=</span> <span class="kt">Lift</span> <span class="p">(</span><span class="kt">State</span> <span class="n">s</span><span class="p">)</span>

<span class="n">hIncrement</span> <span class="o">::</span> <span class="kt">Free</span> <span class="p">(</span><span class="kt">Lift</span> <span class="p">(</span><span class="kt">State</span> <span class="kt">Int</span><span class="p">))</span> <span class="nb">()</span>
<span class="n">hIncrement</span> <span class="o">=</span> <span class="kt">Free</span> <span class="p">(</span><span class="kt">Lift</span> <span class="p">(</span><span class="kt">Get</span> <span class="p">(</span><span class="nf">\</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="p">(</span><span class="kt">Lift</span> <span class="p">(</span><span class="kt">Put</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Pure</span> <span class="nb">()</span><span class="p">))))))</span>

<span class="kr">type</span> <span class="kt">HVoid</span> <span class="o">=</span> <span class="kt">Lift</span> <span class="kt">Void</span>

<span class="n">run</span> <span class="o">::</span> <span class="kt">Free</span> <span class="kt">HVoid</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">run</span> <span class="p">(</span><span class="kt">Pure</span> <span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>
<span class="n">run</span> <span class="kr">_</span> <span class="o">=</span> <span class="n">error</span> <span class="p">(</span><span class="n">pack</span> <span class="s">"impossible"</span><span class="p">)</span>
</pre></table></code></div></div><p>Here <code class="language-plaintext highlighter-rouge">hIncrement</code> is a lifted version of <code class="language-plaintext highlighter-rouge">increment</code> defined before. Likewise, <code class="language-plaintext highlighter-rouge">run</code> remains nearly identical to its previous definition. Making <code class="language-plaintext highlighter-rouge">Lift</code> an instance of <code class="language-plaintext highlighter-rouge">Syntax</code> is a equally straightforward:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre> <span class="kr">instance</span> <span class="kt">Functor</span> <span class="n">sig</span> <span class="o">=&gt;</span> <span class="kt">HFunctor</span> <span class="p">(</span><span class="kt">Lift</span> <span class="n">sig</span><span class="p">)</span> <span class="kr">where</span>
   <span class="n">hmap</span> <span class="n">t</span> <span class="p">(</span><span class="kt">Lift</span> <span class="n">f</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Lift</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">t</span> <span class="n">f</span><span class="p">)</span>

 <span class="kr">instance</span> <span class="kt">Functor</span> <span class="n">sig</span> <span class="o">=&gt;</span> <span class="kt">Syntax</span> <span class="p">(</span><span class="kt">Lift</span> <span class="n">sig</span><span class="p">)</span> <span class="kr">where</span>
   <span class="n">emap</span> <span class="n">t</span> <span class="p">(</span><span class="kt">Lift</span> <span class="n">f</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Lift</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">t</span> <span class="n">f</span><span class="p">)</span>

   <span class="n">weave</span> <span class="n">ctx</span> <span class="n">hdl</span> <span class="p">(</span><span class="kt">Lift</span> <span class="n">f</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Lift</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="nf">\</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">hdl</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="n">const</span> <span class="n">p</span><span class="p">)</span> <span class="n">ctx</span><span class="p">))</span> <span class="n">f</span><span class="p">)</span>
</pre></table></code></div></div><p>The corresponding smart constructors and state handler should look like before, but with our <code class="language-plaintext highlighter-rouge">ctx</code> now carrying the state around:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="n">get</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">s</span> <span class="n">sig</span><span class="o">.</span> <span class="kt">HFunctor</span> <span class="n">sig</span> <span class="o">=&gt;</span> <span class="kt">Member</span> <span class="p">(</span><span class="kt">HState</span> <span class="n">s</span><span class="p">)</span> <span class="n">sig</span> <span class="o">=&gt;</span> <span class="kt">Free</span> <span class="n">sig</span> <span class="n">s</span>
<span class="n">get</span> <span class="o">=</span> <span class="n">inject</span> <span class="p">(</span><span class="kt">Lift</span> <span class="p">(</span><span class="kt">Get</span> <span class="kt">Pure</span><span class="p">))</span>

<span class="n">put</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">s</span> <span class="n">sig</span><span class="o">.</span> <span class="kt">HFunctor</span> <span class="n">sig</span> <span class="o">=&gt;</span> <span class="kt">Member</span> <span class="p">(</span><span class="kt">HState</span> <span class="n">s</span><span class="p">)</span> <span class="n">sig</span> <span class="o">=&gt;</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">sig</span> <span class="nb">()</span>
<span class="n">put</span> <span class="n">s</span> <span class="o">=</span> <span class="n">inject</span> <span class="p">(</span><span class="kt">Lift</span> <span class="p">(</span><span class="kt">Put</span> <span class="n">s</span> <span class="p">(</span><span class="n">pure</span> <span class="nb">()</span><span class="p">)))</span>

<span class="n">runState</span> <span class="o">::</span>
  <span class="n">forall</span> <span class="n">s</span> <span class="n">a</span> <span class="n">sig</span><span class="o">.</span>
  <span class="kt">Syntax</span> <span class="n">sig</span> <span class="o">=&gt;</span>
  <span class="n">s</span> <span class="o">-&gt;</span>
  <span class="kt">Free</span> <span class="p">(</span><span class="kt">HState</span> <span class="n">s</span> <span class="o">:+:</span> <span class="n">sig</span><span class="p">)</span> <span class="n">a</span> <span class="o">-&gt;</span>
  <span class="kt">Free</span> <span class="n">sig</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">runState</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Pure</span> <span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">runState</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">L</span> <span class="p">(</span><span class="kt">Lift</span> <span class="p">(</span><span class="kt">Get</span> <span class="n">f</span><span class="p">))))</span> <span class="o">=</span> <span class="n">runState</span> <span class="n">s</span> <span class="p">(</span><span class="n">f</span> <span class="n">s</span><span class="p">)</span>
<span class="n">runState</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">L</span> <span class="p">(</span><span class="kt">Lift</span> <span class="p">(</span><span class="kt">Put</span> <span class="n">s</span> <span class="n">f</span><span class="p">))))</span> <span class="o">=</span> <span class="n">runState</span> <span class="n">s</span> <span class="n">f</span>
<span class="n">runState</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Free</span> <span class="p">(</span><span class="kt">R</span> <span class="n">other</span><span class="p">))</span> <span class="o">=</span> <span class="kt">Free</span> <span class="p">(</span><span class="n">weave</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">()</span><span class="p">)</span> <span class="n">hdl</span> <span class="n">other</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="n">hdl</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">x</span><span class="o">.</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="kt">Free</span> <span class="p">(</span><span class="kt">HState</span> <span class="n">s</span> <span class="o">:+:</span> <span class="n">sig</span><span class="p">)</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">sig</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">hdl</span> <span class="o">=</span> <span class="n">uncurry</span> <span class="n">runState</span>
</pre></table></code></div></div><p>With all this in place, we can finally construct our <code class="language-plaintext highlighter-rouge">countDown</code> example again:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">countDown</span> <span class="o">::</span>
  <span class="n">forall</span> <span class="n">sig</span><span class="o">.</span>
  <span class="kt">Syntax</span> <span class="n">sig</span> <span class="o">=&gt;</span>
  <span class="kt">Member</span> <span class="p">(</span><span class="kt">HState</span> <span class="kt">Int</span><span class="p">)</span> <span class="n">sig</span> <span class="o">=&gt;</span>
  <span class="kt">Member</span> <span class="p">(</span><span class="kt">Error</span> <span class="nb">()</span><span class="p">)</span> <span class="n">sig</span> <span class="o">=&gt;</span>
  <span class="kt">Free</span> <span class="n">sig</span> <span class="nb">()</span>
<span class="n">countDown</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">decr</span> <span class="cm">{- 1 -}</span>
  <span class="n">catch</span> <span class="p">(</span><span class="n">decr</span> <span class="cm">{- 2 -}</span> <span class="o">&gt;&gt;</span> <span class="n">decr</span> <span class="cm">{- 3 -}</span><span class="p">)</span> <span class="n">pure</span>
  <span class="kr">where</span>
    <span class="n">decr</span> <span class="o">=</span> <span class="kr">do</span>
      <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">get</span> <span class="o">@</span><span class="kt">Int</span>
      <span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="kr">then</span> <span class="n">put</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="kr">else</span> <span class="n">throw</span> <span class="nb">()</span>
</pre></table></code></div></div><p>Now if we encounter an error within our <code class="language-plaintext highlighter-rouge">catch</code> statement, the local state semantics are respected:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">run</span> <span class="o">.</span> <span class="n">runError</span> <span class="o">@</span><span class="nb">()</span> <span class="o">.</span> <span class="n">runState</span> <span class="o">@</span><span class="kt">Int</span> <span class="mi">2</span> <span class="o">$</span> <span class="n">countDown</span>
<span class="kt">Right</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">()</span><span class="p">)</span>
</pre></table></code></div></div><p>Pay attention to <em>why</em> this works - we first use our <code class="language-plaintext highlighter-rouge">runState</code> handler and eventually encounter <code class="language-plaintext highlighter-rouge">decr {- 3 -}</code> which returns <code class="language-plaintext highlighter-rouge">throw ()</code> instead of <code class="language-plaintext highlighter-rouge">put (x - 1)</code>. During this process, weave was invoked on a <code class="language-plaintext highlighter-rouge">Catch</code> with context <code class="language-plaintext highlighter-rouge">(s, )</code> used to maintain the state at the time. Next <code class="language-plaintext highlighter-rouge">runError</code> is invoked which sees the <code class="language-plaintext highlighter-rouge">Catch</code>, encounters the returned <code class="language-plaintext highlighter-rouge">Throw</code> after running the scoped program, and invokes the error handler which has our saved state.</p><h1 id="limitations">Limitations</h1><p>Though the higher-order free implementation is largely a useful tool for managing effects, it is not perfect. I’ve had an especially hard time getting resource-oriented effects working, e.g. with custom effects like so:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kr">data</span> <span class="kt">Server</span> <span class="n">hdl</span> <span class="n">conn</span> <span class="p">(</span><span class="n">m</span> <span class="o">::</span> <span class="o">*</span> <span class="o">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="n">k</span> <span class="kr">where</span>
  <span class="kt">Start</span> <span class="o">::</span> <span class="kt">SpawnOptions</span> <span class="o">-&gt;</span> <span class="kt">Server</span> <span class="n">hdl</span> <span class="n">conn</span> <span class="n">m</span> <span class="n">hdl</span>
  <span class="kt">Stop</span> <span class="o">::</span> <span class="n">hdl</span> <span class="o">-&gt;</span> <span class="kt">Server</span> <span class="n">hdl</span> <span class="n">conn</span> <span class="n">m</span> <span class="kt">ExitCode</span>
  <span class="kt">GetPort</span> <span class="o">::</span> <span class="n">hdl</span> <span class="o">-&gt;</span> <span class="kt">Server</span> <span class="n">hdl</span> <span class="n">conn</span> <span class="n">m</span> <span class="kt">PortNumber</span>
  <span class="kt">Open</span> <span class="o">::</span> <span class="kt">Text</span> <span class="o">-&gt;</span> <span class="kt">PortNumber</span> <span class="o">-&gt;</span> <span class="kt">Server</span> <span class="n">hdl</span> <span class="n">conn</span> <span class="n">m</span> <span class="n">conn</span>
  <span class="kt">Close</span> <span class="o">::</span> <span class="n">conn</span> <span class="o">-&gt;</span> <span class="kt">Server</span> <span class="n">hdl</span> <span class="n">conn</span> <span class="n">m</span> <span class="nb">()</span>
</pre></table></code></div></div><p>The issue here being running the custom <code class="language-plaintext highlighter-rouge">Server</code> handler invokes <code class="language-plaintext highlighter-rouge">start</code> <em>and</em> <code class="language-plaintext highlighter-rouge">stop</code> when wrapped in some <a href="https://github.com/fused-effects/fused-effects-exceptions">bracket</a>-like interface, even if the bracketed code has not yet finished. I have settled on workarounds, but these workarounds consist of just structuring these kind of effects differently.</p><p>In general, modeling asynchronous or <code class="language-plaintext highlighter-rouge">IO</code>-oriented operations feel “unsolved” with solutions resorting to some <a href="https://apfelmus.nfshost.com/blog/2012/06/07-forklift.html">forklift</a> strategy or other ad-hoc solutions that don’t feel as cemented in literature. I don’t necessarily think these are the <em>wrong</em> approach (I frankly don’t know enough to have a real opinion here), but it’d be nice to feel there was some consensus as to what a non-hacky solution theoretically looks like.</p><p>Additionally, it is cumbersome remembering the order handlers should be applied to achieve the desired global vs. local state semantics. This is not exclusively a problem of free effect systems (e.g. MTL also suffers from this), but the issue feels more prominent here.</p><h1 id="conclusion">Conclusion</h1><p>I will continue exploring effect systems à la free, but I am admittedly not yet convinced they are the right way forward. Unfortunately, they can be hard to reason about with unexpected interactions between effects if not careful. I am sure a large contributing factor to this conclusion is the lack of beginner-oriented documentation regarding proper use and edge cases. Just to build up this post required reading source code of multiple effects libraries and scattered blog posts, watching various YouTube videos, etc. And, despite all that, I am still not confident I understand the implementation details behind certain key abstractions. Hopefully this entry threads the needle between exposition and overt jargon to get us a little closer though.</p><p> </p><hr /><div class="footnotes" role="doc-endnotes"><ol><li id="fn:1" role="doc-endnote"><p>Though there exists a categorical definition of what makes something <strong>free</strong>, in this case it suffices to substitute “free” with “systematic”. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p></ol></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/programming/'>Programming</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/haskell/" class="post-tag no-text-decoration" >haskell</a> <a href="/tags/functional/" class="post-tag no-text-decoration" >functional</a> <a href="/tags/programming/" class="post-tag no-text-decoration" >programming</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/functional/">functional</a> <a class="post-tag" href="/tags/haskell/">haskell</a> <a class="post-tag" href="/tags/programming/">programming</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/tagless-final-parsing/"><div class="card-body"> <span class="timeago small" >Dec 26, 2021<i class="unloaded">2021-12-26T00:00:00-05:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Tagless Final Parsing</h3><div class="text-muted small"><p> In his introductory text, Oleg Kiselyov discusses the tagless final strategy for implementing DSLs. The approach permits leveraging the strong typing provided by some host language in a performant ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/tagless-final-parsing/" class="btn btn-outline-primary" prompt="Older"><p>Tagless Final Parsing</p></a> <span class="btn btn-outline-primary disabled" prompt="Newer"><p>-</p></span></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/jrpotter">Joshua Potter</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/functional/">functional</a> <a class="post-tag" href="/tags/haskell/">haskell</a> <a class="post-tag" href="/tags/programming/">programming</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
