<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="Tagless Final Parsing" /><meta property="og:locale" content="en" /><meta name="description" content="In his introductory text, Oleg Kiselyov discusses the tagless final strategy for implementing DSLs. The approach permits leveraging the strong typing provided by some host language in a performant way. This post combines key thoughts from a selection of papers and code written on the topic. We conclude with an implementation of an interpreter for a toy language that runs quickly, remains strongly-typed, and can be extended without modification." /><meta property="og:description" content="In his introductory text, Oleg Kiselyov discusses the tagless final strategy for implementing DSLs. The approach permits leveraging the strong typing provided by some host language in a performant way. This post combines key thoughts from a selection of papers and code written on the topic. We conclude with an implementation of an interpreter for a toy language that runs quickly, remains strongly-typed, and can be extended without modification." /><link rel="canonical" href="https://jrpotter.github.io/posts/tagless-final-parsing/" /><meta property="og:url" content="https://jrpotter.github.io/posts/tagless-final-parsing/" /><meta property="og:site_name" content="Joshua Potter" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-12-26T00:00:00-05:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Tagless Final Parsing" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"In his introductory text, Oleg Kiselyov discusses the tagless final strategy for implementing DSLs. The approach permits leveraging the strong typing provided by some host language in a performant way. This post combines key thoughts from a selection of papers and code written on the topic. We conclude with an implementation of an interpreter for a toy language that runs quickly, remains strongly-typed, and can be extended without modification.","url":"https://jrpotter.github.io/posts/tagless-final-parsing/","@type":"BlogPosting","headline":"Tagless Final Parsing","dateModified":"2021-12-26T00:00:00-05:00","datePublished":"2021-12-26T00:00:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://jrpotter.github.io/posts/tagless-final-parsing/"},"@context":"https://schema.org"}</script><title>Tagless Final Parsing | Joshua Potter</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Joshua Potter"><meta name="application-name" content="Joshua Potter"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://avatars.githubusercontent.com/u/3267697?v=4" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Joshua Potter</a></div><div class="site-subtitle font-italic">A series of personal explorations.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/projects/" class="nav-link"> <i class="fa-fw fas fa-project-diagram ml-xl-3 mr-xl-3 unloaded"></i> <span>PROJECTS</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/jrpotter" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Tagless Final Parsing</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Tagless Final Parsing</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Joshua Potter </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Dec 26, 2021, 12:00 AM -0500" >Dec 26, 2021<i class="unloaded">2021-12-26T00:00:00-05:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5297 words">29 min read</span></div></div><div class="post-content"><p>In his <a href="https://okmij.org/ftp/tagless-final/course/lecture.pdf">introductory text</a>, Oleg Kiselyov discusses the <strong>tagless final</strong> strategy for implementing DSLs. The approach permits leveraging the strong typing provided by some host language in a performant way. This post combines key thoughts from a selection of papers and code written on the topic. We conclude with an implementation of an interpreter for a toy language that runs quickly, remains strongly-typed, and can be extended without modification.</p><ul id="markdown-toc"><li><a href="#introduction" id="markdown-toc-introduction">Introduction</a><li><a href="#initial-encoding" id="markdown-toc-initial-encoding">Initial Encoding</a><ul><li><a href="#single-pass" id="markdown-toc-single-pass">Single Pass</a><li><a href="#resource-usage" id="markdown-toc-resource-usage">Resource Usage</a><li><a href="#type-safety" id="markdown-toc-type-safety">Type Safety</a><li><a href="#expression-problem" id="markdown-toc-expression-problem">Expression Problem</a></ul><li><a href="#tagless-final" id="markdown-toc-tagless-final">Tagless Final</a><ul><li><a href="#leibniz-equality" id="markdown-toc-leibniz-equality">Leibniz Equality</a><li><a href="#dynamics" id="markdown-toc-dynamics">Dynamics</a><li><a href="#interpretations" id="markdown-toc-interpretations">Interpretations</a><li><a href="#expression-revisited" id="markdown-toc-expression-revisited">Expression Revisited</a><ul><li><a href="#copy-symantics" id="markdown-toc-copy-symantics">Copy Symantics</a></ul></ul><li><a href="#limitations" id="markdown-toc-limitations">Limitations</a><li><a href="#conclusion" id="markdown-toc-conclusion">Conclusion</a></ul><h1 id="introduction">Introduction</h1><p>To get started, let’s write what our toy language will look like.</p><div class="language-ebnf highlighter-rouge"><div class="code-header"> <span text-data="EBNF"><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!" data-original-title="" title=""> <i class="far fa-clipboard"></i> </button></div><div class="highlight"> <code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>
digit = ? any number between 0-9 ? ;

(* We ignore any leading 0s *)
integer = digit, { digit } ;
e_integer = [ e_integer, ("+" | "-") ]
          , ( "(", e_integer, ")" | integer )
          ;

boolean = "true" | "false" ;
e_boolean = [ e_boolean, ("&amp;&amp;" | "||") ]
          , ( "(", e_boolean, ")" | boolean )
          ;

expr = e_integer | e_boolean ;
</pre></table></code></div></div><p>The above expresses addition, subtraction, conjunction, and disjunction, to be interpreted in the standard way. All operations are left-associative, with default precedence disrupted via parenthesis (<code class="language-plaintext highlighter-rouge">()</code>). Our goal is to use <a href="https://hackage.haskell.org/package/megaparsec">megaparsec</a> to interpret programs in this language, raising errors on malformed or invalidly-typed inputs. We will evaluate interpreter performance on inputs such as those generated by</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">echo</span> <span class="o">{</span>1..10000000<span class="o">}</span> | <span class="nb">sed</span> <span class="s1">'s/ / + /g'</span> <span class="o">&gt;</span> input.txt
</pre></table></code></div></div><div class="alert alert-info" role="alert"><div><i class="fa fa-info-circle"></i> <strong>Info</strong></div><p>To support inputs like above, ideally we mix lazy and strict functionality. For example, we should lazily load in a file but strictly evaluate its contents. Certain languages struggle without this more nuanced evaluation strategy, e.g.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="o">(</span><span class="nb">echo</span> <span class="nt">-n</span> <span class="s1">'print('</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="nt">-n</span> <span class="o">{</span>1..10000000<span class="o">}</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s1">')'</span><span class="o">)</span> |
    <span class="nb">sed</span> <span class="s1">'s/ / + /g'</span> <span class="o">&gt;</span> input.py
<span class="nv">$ </span>python3 input.py
Segmentation fault: 11
</pre></table></code></div></div><p>Note it’d actually be more efficient on our end to not use megaparsec at all! The library loads in the entirety of to-be-parsed text into memory, but using it will hopefully be more representative of projects out in the wild.</p></div><h1 id="initial-encoding">Initial Encoding</h1><p>How might we instinctively choose to tackle an interpreter of our language? As one might expect, megaparsec already has all the tooling needed to parse expressions. We can represent our expressions and results straightforwardly like so:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kr">data</span> <span class="kt">Expr</span>
  <span class="o">=</span> <span class="kt">EInt</span>  <span class="kt">Integer</span>
  <span class="o">|</span> <span class="kt">EBool</span> <span class="kt">Bool</span>
  <span class="o">|</span> <span class="kt">EAdd</span>  <span class="kt">Expr</span> <span class="kt">Expr</span>
  <span class="o">|</span> <span class="kt">ESub</span>  <span class="kt">Expr</span> <span class="kt">Expr</span>
  <span class="o">|</span> <span class="kt">EAnd</span>  <span class="kt">Expr</span> <span class="kt">Expr</span>
  <span class="o">|</span> <span class="kt">EOr</span>   <span class="kt">Expr</span> <span class="kt">Expr</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Result</span> <span class="o">=</span> <span class="kt">RInt</span> <span class="kt">Integer</span> <span class="o">|</span> <span class="kt">RBool</span> <span class="kt">Bool</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">)</span>
</pre></table></code></div></div><p>We use a standard ADT to describe the structure of our program, nesting the same data type recursively to represent precedence. For instance, we would expect a (so-far fictional) function <code class="language-plaintext highlighter-rouge">parse</code> to give us</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">parse</span> <span class="s">"1 + 2 + 3"</span>
<span class="kt">EAdd</span> <span class="p">(</span><span class="kt">EAdd</span> <span class="p">(</span><span class="kt">EInt</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">EInt</span> <span class="mi">2</span><span class="p">))</span> <span class="p">(</span><span class="kt">EInt</span> <span class="mi">3</span><span class="p">)</span>
</pre></table></code></div></div><p>We can then evaluate expressions within our <code class="language-plaintext highlighter-rouge">Expr</code> type. Notice we must wrap our result within some <code class="language-plaintext highlighter-rouge">Error</code>-like monad considering the ADT does not necessarily correspond to a well-typed expression in our language.</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="n">asInt</span> <span class="o">::</span> <span class="kt">Result</span> <span class="o">-&gt;</span> <span class="kt">Either</span> <span class="kt">Text</span> <span class="kt">Integer</span>
<span class="n">asInt</span> <span class="p">(</span><span class="kt">RInt</span> <span class="n">e</span><span class="p">)</span> <span class="o">=</span> <span class="n">pure</span> <span class="n">e</span>
<span class="n">asInt</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">Left</span> <span class="s">"Could not cast integer."</span>

<span class="n">asBool</span> <span class="o">::</span> <span class="kt">Result</span> <span class="o">-&gt;</span> <span class="kt">Either</span> <span class="kt">Text</span> <span class="kt">Bool</span>
<span class="n">asBool</span> <span class="p">(</span><span class="kt">RBool</span> <span class="n">e</span><span class="p">)</span> <span class="o">=</span> <span class="n">pure</span> <span class="n">e</span>
<span class="n">asBool</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">Left</span> <span class="s">"Could not cast boolean."</span>

<span class="n">toResult</span> <span class="o">::</span> <span class="kt">Expr</span> <span class="o">-&gt;</span> <span class="kt">Either</span> <span class="kt">Text</span> <span class="kt">Result</span>
<span class="n">toResult</span> <span class="p">(</span><span class="kt">EInt</span> <span class="n">e</span><span class="p">)</span>  <span class="o">=</span> <span class="n">pure</span> <span class="o">$</span> <span class="kt">RInt</span> <span class="n">e</span>
<span class="n">toResult</span> <span class="p">(</span><span class="kt">EBool</span> <span class="n">e</span><span class="p">)</span> <span class="o">=</span> <span class="n">pure</span> <span class="o">$</span> <span class="kt">RBool</span> <span class="n">e</span>
<span class="n">toResult</span> <span class="p">(</span><span class="kt">EAdd</span> <span class="n">lhs</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">lhs'</span> <span class="o">&lt;-</span> <span class="n">toResult</span> <span class="n">lhs</span> <span class="o">&gt;&gt;=</span> <span class="n">asInt</span>
  <span class="n">rhs'</span> <span class="o">&lt;-</span> <span class="n">toResult</span> <span class="n">rhs</span> <span class="o">&gt;&gt;=</span> <span class="n">asInt</span>
  <span class="n">pure</span> <span class="o">$</span> <span class="kt">RInt</span> <span class="p">(</span><span class="n">lhs'</span> <span class="o">+</span> <span class="n">rhs'</span><span class="p">)</span>
<span class="n">toResult</span> <span class="p">(</span><span class="kt">ESub</span> <span class="n">lhs</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">lhs'</span> <span class="o">&lt;-</span> <span class="n">toResult</span> <span class="n">lhs</span> <span class="o">&gt;&gt;=</span> <span class="n">asInt</span>
  <span class="n">rhs'</span> <span class="o">&lt;-</span> <span class="n">toResult</span> <span class="n">rhs</span> <span class="o">&gt;&gt;=</span> <span class="n">asInt</span>
  <span class="n">pure</span> <span class="o">$</span> <span class="kt">RInt</span> <span class="p">(</span><span class="n">lhs'</span> <span class="o">-</span> <span class="n">rhs'</span><span class="p">)</span>
<span class="n">toResult</span> <span class="p">(</span><span class="kt">EAnd</span> <span class="n">lhs</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">lhs'</span> <span class="o">&lt;-</span> <span class="n">toResult</span> <span class="n">lhs</span> <span class="o">&gt;&gt;=</span> <span class="n">asBool</span>
  <span class="n">rhs'</span> <span class="o">&lt;-</span> <span class="n">toResult</span> <span class="n">rhs</span> <span class="o">&gt;&gt;=</span> <span class="n">asBool</span>
  <span class="n">pure</span> <span class="o">$</span> <span class="kt">RBool</span> <span class="p">(</span><span class="n">lhs'</span> <span class="o">&amp;&amp;</span> <span class="n">rhs'</span><span class="p">)</span>
<span class="n">toResult</span> <span class="p">(</span><span class="kt">EOr</span> <span class="n">lhs</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">lhs'</span> <span class="o">&lt;-</span> <span class="n">toResult</span> <span class="n">lhs</span> <span class="o">&gt;&gt;=</span> <span class="n">asBool</span>
  <span class="n">rhs'</span> <span class="o">&lt;-</span> <span class="n">toResult</span> <span class="n">rhs</span> <span class="o">&gt;&gt;=</span> <span class="n">asBool</span>
  <span class="n">pure</span> <span class="o">$</span> <span class="kt">RBool</span> <span class="p">(</span><span class="n">lhs'</span> <span class="o">||</span> <span class="n">rhs'</span><span class="p">)</span>
</pre></table></code></div></div><p>With the above in place, we can begin fleshing out our first parsing attempt. A naive solution may look as follows:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">parseNaive</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Result</span>
<span class="n">parseNaive</span> <span class="o">=</span> <span class="n">expr</span> <span class="o">&gt;&gt;=</span> <span class="n">either</span> <span class="p">(</span><span class="n">fail</span> <span class="o">.</span> <span class="n">unpack</span><span class="p">)</span> <span class="n">pure</span> <span class="o">.</span> <span class="n">toResult</span>
 <span class="kr">where</span>
  <span class="n">expr</span> <span class="o">=</span> <span class="kt">E</span><span class="o">.</span><span class="n">makeExprParser</span> <span class="n">term</span>
    <span class="p">[</span> <span class="p">[</span><span class="n">binary</span> <span class="s">"+"</span> <span class="kt">EAdd</span><span class="p">,</span> <span class="n">binary</span> <span class="s">"-"</span> <span class="kt">ESub</span><span class="p">]</span>
    <span class="p">,</span> <span class="p">[</span><span class="n">binary</span> <span class="s">"&amp;&amp;"</span> <span class="kt">EAnd</span><span class="p">,</span> <span class="n">binary</span> <span class="s">"||"</span> <span class="kt">EOr</span><span class="p">]</span>
    <span class="p">]</span>

  <span class="n">binary</span> <span class="n">name</span> <span class="n">f</span> <span class="o">=</span> <span class="kt">E</span><span class="o">.</span><span class="kt">InfixL</span> <span class="p">(</span><span class="n">f</span> <span class="o">&lt;$</span> <span class="n">symbol</span> <span class="n">name</span><span class="p">)</span>

  <span class="n">term</span> <span class="o">=</span> <span class="n">parens</span> <span class="n">expr</span> <span class="o">&lt;|&gt;</span> <span class="kt">EInt</span> <span class="o">&lt;$&gt;</span> <span class="n">integer</span> <span class="o">&lt;|&gt;</span> <span class="kt">EBool</span> <span class="o">&lt;$&gt;</span> <span class="n">boolean</span>
</pre></table></code></div></div><p>There are certainly components of the above implementation that raises eyebrows (at least in the context of large inputs), but that could potentially be overlooked depending on how well it runs. Running <code class="language-plaintext highlighter-rouge">parseNaive</code><sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> against <code class="language-plaintext highlighter-rouge">input.txt</code> shows little promise though:</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nv">$ </span>cabal run <span class="nt">--enable-profiling</span> exe:initial-encoding <span class="nt">--</span> input.txt +RTS <span class="nt">-s</span>
50000005000000
...
            4126 MiB total memory <span class="k">in </span>use <span class="o">(</span>0 MB lost due to fragmentation<span class="o">)</span>
...
  Total   <span class="nb">time   </span>25.541s  <span class="o">(</span> 27.121s elapsed<span class="o">)</span>
...
  Productivity  82.3% of total user, 78.9% of total elapsed

</pre></table></code></div></div><p>A few immediate takeaways from this exercise:</p><p>This solution</p><ul><li>has to run through the generated AST twice. First to build the AST and second to type-check and evaluate the code (i.e. <code class="language-plaintext highlighter-rouge">toResult</code>).<li>is resource intensive. It consumes a large amount of memory (approximately <code class="language-plaintext highlighter-rouge">4</code> GiB in the above run) and is far too slow. A stream of 10,000,000 integers should be quick and cheap to sum together.<li>is unsafe. Packaged as a library, there are no typing guarantees we leverage from our host language. For example, expression <code class="language-plaintext highlighter-rouge">EAnd (EInt 1) (EInt 2)</code> is valid.<li>suffers from the <a href="https://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt">expression problem</a>. Developers cannot extend our language with new operations without having to modify the source.</ul><p>Let’s tackle each of these problems in turn.</p><h2 id="single-pass">Single Pass</h2><p>Our naive attempt separated parsing from evaluation because they fail in different ways. The former raises a <code class="language-plaintext highlighter-rouge">ParseErrorBundle</code> on invalid input while the latter raises a <code class="language-plaintext highlighter-rouge">Text</code> on mismatched types. Ideally we would have a single error type shared by both of these failure modes. Unfortunately, this is not so simple - the <code class="language-plaintext highlighter-rouge">Operator</code> types found within <code class="language-plaintext highlighter-rouge">makeExprParser</code> have incompatible function signatures. In particular, <code class="language-plaintext highlighter-rouge">InfixL</code> is defined as</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">InfixL</span> <span class="o">::</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Operator</span> <span class="n">m</span> <span class="n">a</span>
</pre></table></code></div></div><p>instead of</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">InfixL</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Operator</span> <span class="n">m</span> <span class="n">a</span>
</pre></table></code></div></div><p>To work around these limitations, we define our binary functions to operate and return on values of type <code class="language-plaintext highlighter-rouge">Either Text Expr</code>. We then raise a <code class="language-plaintext highlighter-rouge">Left</code> on type mismatch, deferring error reporting at the <code class="language-plaintext highlighter-rouge">Parser</code> level until the current expression is fully parsed:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="n">parseSingle</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Result</span>
<span class="n">parseSingle</span> <span class="o">=</span> <span class="n">expr</span> <span class="o">&gt;&gt;=</span> <span class="n">either</span> <span class="p">(</span><span class="n">fail</span> <span class="o">.</span> <span class="n">unpack</span><span class="p">)</span> <span class="n">pure</span>
 <span class="kr">where</span>
  <span class="n">expr</span> <span class="o">=</span> <span class="kt">E</span><span class="o">.</span><span class="n">makeExprParser</span> <span class="n">term</span>
    <span class="p">[</span> <span class="p">[</span><span class="n">binary</span> <span class="s">"+"</span>  <span class="n">asInt</span>  <span class="kt">EInt</span>  <span class="kt">EAdd</span><span class="p">,</span> <span class="n">binary</span> <span class="s">"-"</span>  <span class="n">asInt</span>  <span class="kt">EInt</span>  <span class="kt">ESub</span><span class="p">]</span>
    <span class="p">,</span> <span class="p">[</span><span class="n">binary</span> <span class="s">"&amp;&amp;"</span> <span class="n">asBool</span> <span class="kt">EBool</span> <span class="kt">EAnd</span><span class="p">,</span> <span class="n">binary</span> <span class="s">"||"</span> <span class="n">asBool</span> <span class="kt">EBool</span> <span class="kt">EOr</span> <span class="p">]</span>
    <span class="p">]</span>

  <span class="n">binary</span> <span class="n">name</span> <span class="n">cast</span> <span class="n">f</span> <span class="n">bin</span> <span class="o">=</span> <span class="kt">E</span><span class="o">.</span><span class="kt">InfixL</span> <span class="kr">do</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">symbol</span> <span class="n">name</span>
    <span class="n">pure</span> <span class="o">$</span> <span class="nf">\</span><span class="n">lhs</span> <span class="n">rhs</span> <span class="o">-&gt;</span> <span class="kr">do</span>
      <span class="n">lhs'</span> <span class="o">&lt;-</span> <span class="n">lhs</span> <span class="o">&gt;&gt;=</span> <span class="n">cast</span>
      <span class="n">rhs'</span> <span class="o">&lt;-</span> <span class="n">rhs</span> <span class="o">&gt;&gt;=</span> <span class="n">cast</span>
      <span class="n">toResult</span> <span class="o">$</span> <span class="n">bin</span> <span class="p">(</span><span class="n">f</span> <span class="n">lhs'</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="n">rhs'</span><span class="p">)</span>

  <span class="n">term</span> <span class="o">=</span> <span class="n">parens</span> <span class="n">expr</span> <span class="o">&lt;|&gt;</span>
         <span class="kt">Right</span> <span class="o">.</span> <span class="kt">RInt</span> <span class="o">&lt;$&gt;</span> <span class="n">integer</span> <span class="o">&lt;|&gt;</span>
         <span class="kt">Right</span> <span class="o">.</span> <span class="kt">RBool</span> <span class="o">&lt;$&gt;</span> <span class="n">boolean</span>
</pre></table></code></div></div><h2 id="resource-usage">Resource Usage</h2><p>Though our above strategy avoids two <em>explicit</em> passes through the AST, laziness sets it up so that we build this intertwined callstack without actually evaluating anything until we interpret the returned <code class="language-plaintext highlighter-rouge">Result</code>. The generated runtime statistics are actually worse as a result:</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>cabal run <span class="nt">--enable-profiling</span> exe:initial-encoding <span class="nt">--</span> <span class="se">\</span>
  input.txt <span class="nt">-m</span> single +RTS <span class="nt">-s</span>
</pre></table></code></div></div><p>We’ll use a heap profile to make the implementation’s shortcomings more obvious:</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>cabal run <span class="nt">--enable-profiling</span> exe:initial-encoding <span class="nt">--</span> <span class="se">\</span>
  input.txt <span class="nt">-m</span> single +RTS <span class="nt">-hr</span>
</pre></table></code></div></div><div class="alert alert-success" role="alert"><div><i class="fa fa-lightbulb"></i> <strong>Tip</strong></div><p>To iterate faster, reduce the number of integers in <code class="language-plaintext highlighter-rouge">input.txt</code>. The resulting heap profile should remain proportional to the original. Just make sure the program runs for long enough to actually perform meaningful profiling. This section works on inputs of 100,000 integers.</p></div><p>The generated heap profile, broken down by retainer set, looks as follows:</p><p><img data-proofer-ignore data-src="/assets/img/tagless-final-parsing/parser-initial-100k-heap-hr-single.png" alt="parser-initial-100k-heap-hr-single" /></p><p>Our top-level expression parser continues growing in size until the program nears completion, presumably when the expression is finally evaluated. To further pinpoint the leaky methods, we re-run the heap generation by cost-centre stack to get:</p><p><img data-proofer-ignore data-src="/assets/img/tagless-final-parsing/parser-initial-100k-heap-hc-single.png" alt="parser-initial-100k-heap-hc-single" /></p><p>Even our straightforward lexing functions are holding on to memory. The laziness and left associative nature of our grammar hints that we may be dealing with a thunk stack reminiscient of <a href="https://wiki.haskell.org/Foldr_Foldl_Foldl%27">foldl</a>. This implies we could fix the issue by evaluating our data strictly with e.g. <a href="https://hackage.haskell.org/package/deepseq">deepseq</a>. The problem is unfortunately deeper than this though. Consider the definition of <a href="https://hackage.haskell.org/package/parser-combinators-1.3.0/docs/src/Control.Monad.Combinators.Expr.html#pInfixL">InfixL</a>’s parser:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">pInfixL</span> <span class="o">::</span> <span class="kt">MonadPlus</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="n">pInfixL</span> <span class="n">op</span> <span class="n">p</span> <span class="n">x</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">f</span> <span class="o">&lt;-</span> <span class="n">op</span>
  <span class="n">y</span> <span class="o">&lt;-</span> <span class="n">p</span>
  <span class="kr">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span>
  <span class="n">pInfixL</span> <span class="n">op</span> <span class="n">p</span> <span class="n">r</span> <span class="o">&lt;|&gt;</span> <span class="n">return</span> <span class="n">r</span>
</pre></table></code></div></div><p>Because this implementation uses the backtracking alternative operator (<code class="language-plaintext highlighter-rouge">&lt;|&gt;</code>), we must also hold onto each <code class="language-plaintext highlighter-rouge">&lt;|&gt; return r</code> in memory “just in case” we need to use it. Since we are working with a <a href="https://www.csd.uwo.ca/~mmorenom/CS447/Lectures/Syntax.html/node9.html">left-factored</a> grammar, we can drop the alternatives and apply strictness with a custom expression parser:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="n">parseStrict</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Result</span>
<span class="n">parseStrict</span> <span class="o">=</span> <span class="n">term</span> <span class="o">&gt;&gt;=</span> <span class="n">expr</span>
 <span class="kr">where</span>
  <span class="n">expr</span> <span class="n">t</span> <span class="o">=</span> <span class="kr">do</span>
    <span class="n">op</span> <span class="o">&lt;-</span> <span class="kt">M</span><span class="o">.</span><span class="n">option</span> <span class="kt">Nothing</span> <span class="o">$</span> <span class="kt">Just</span> <span class="o">&lt;$&gt;</span> <span class="n">ops</span>
    <span class="kr">case</span> <span class="n">op</span> <span class="kr">of</span>
      <span class="kt">Just</span> <span class="kt">OpAdd</span> <span class="o">-&gt;</span> <span class="n">nest</span> <span class="n">t</span> <span class="n">asInt</span>  <span class="kt">EInt</span>  <span class="kt">EAdd</span>
      <span class="kt">Just</span> <span class="kt">OpSub</span> <span class="o">-&gt;</span> <span class="n">nest</span> <span class="n">t</span> <span class="n">asInt</span>  <span class="kt">EInt</span>  <span class="kt">ESub</span>
      <span class="kt">Just</span> <span class="kt">OpAnd</span> <span class="o">-&gt;</span> <span class="n">nest</span> <span class="n">t</span> <span class="n">asBool</span> <span class="kt">EBool</span> <span class="kt">EAnd</span>
      <span class="kt">Just</span> <span class="kt">OpOr</span>  <span class="o">-&gt;</span> <span class="n">nest</span> <span class="n">t</span> <span class="n">asBool</span> <span class="kt">EBool</span> <span class="kt">EOr</span>
      <span class="kr">_</span>          <span class="o">-&gt;</span> <span class="n">pure</span> <span class="n">t</span>

  <span class="n">nest</span>
    <span class="o">::</span> <span class="n">forall</span> <span class="n">a</span>
     <span class="o">.</span> <span class="kt">Result</span>
    <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Result</span> <span class="o">-&gt;</span> <span class="kt">Either</span> <span class="kt">Text</span> <span class="n">a</span><span class="p">)</span>
    <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Expr</span><span class="p">)</span>
    <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Expr</span> <span class="o">-&gt;</span> <span class="kt">Expr</span> <span class="o">-&gt;</span> <span class="kt">Expr</span><span class="p">)</span>
    <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="kt">Result</span>
  <span class="n">nest</span> <span class="n">t</span> <span class="n">cast</span> <span class="n">f</span> <span class="n">bin</span> <span class="o">=</span> <span class="kr">do</span>
    <span class="n">t'</span> <span class="o">&lt;-</span> <span class="n">term</span>
    <span class="n">a</span> <span class="o">&lt;-</span> <span class="n">either</span> <span class="p">(</span><span class="n">fail</span> <span class="o">.</span> <span class="n">unpack</span><span class="p">)</span> <span class="n">pure</span> <span class="kr">do</span>
      <span class="n">lhs</span> <span class="o">&lt;-</span> <span class="n">cast</span> <span class="n">t</span>
      <span class="n">rhs</span> <span class="o">&lt;-</span> <span class="n">cast</span> <span class="n">t'</span>
      <span class="n">toResult</span> <span class="o">$</span> <span class="n">bin</span> <span class="p">(</span><span class="n">f</span> <span class="n">lhs</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="n">rhs</span><span class="p">)</span>
    <span class="n">a</span> <span class="p">`</span><span class="n">deepseq</span><span class="p">`</span> <span class="n">expr</span> <span class="n">a</span>

  <span class="n">term</span> <span class="o">=</span> <span class="kr">do</span>
    <span class="n">p</span> <span class="o">&lt;-</span> <span class="kt">M</span><span class="o">.</span><span class="n">option</span> <span class="kt">Nothing</span> <span class="o">$</span> <span class="kt">Just</span> <span class="o">&lt;$&gt;</span> <span class="n">symbol</span> <span class="s">"("</span>
    <span class="kr">if</span> <span class="n">isJust</span> <span class="n">p</span> <span class="kr">then</span> <span class="p">(</span><span class="n">term</span> <span class="o">&gt;&gt;=</span> <span class="n">expr</span><span class="p">)</span> <span class="o">&lt;*</span> <span class="n">symbol</span> <span class="s">")"</span> <span class="kr">else</span>
      <span class="kt">RInt</span> <span class="o">&lt;$&gt;</span> <span class="n">integer</span> <span class="o">&lt;|&gt;</span> <span class="kt">RBool</span> <span class="o">&lt;$&gt;</span> <span class="n">boolean</span>
</pre></table></code></div></div><p>This implementation runs marginally faster and uses a constant amount of memory:</p><p><img data-proofer-ignore data-src="/assets/img/tagless-final-parsing/parser-initial-100k-heap-hd-strict.png" alt="parser-initial-100k-heap-hd-strict" /></p><div class="alert alert-info" role="alert"><div><i class="fa fa-info-circle"></i> <strong>Info</strong></div><p><code class="language-plaintext highlighter-rouge">ARR_WORDS</code> corresponds to the <code class="language-plaintext highlighter-rouge">ByteString</code> constructor and is unavoidable so long as we use megaparsec.</p></div><p>To get a better sense of where runtime tends to reside, let’s re-run our newly strict implementation on our 10,000,000 file again alongside a time profile:</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nb">echo</span> <span class="o">{</span>1..10000000<span class="o">}</span> | <span class="nb">sed</span> <span class="s1">'s/ / + /g'</span> <span class="o">&gt;</span> input.txt
cabal run <span class="nt">--enable-profiling</span> exe:initial-encoding <span class="nt">--</span> <span class="se">\</span>
  input.txt <span class="nt">-m</span> strict +RTS <span class="nt">-p</span>
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>space          Text.Megaparsec.Lexer      Text/Megaparsec/Lexer.hs:(68,1)-(71,44)                 54.9   57.3
decimal        Text.Megaparsec.Char.Lexer Text/Megaparsec/Char/Lexer.hs:363:1-32                  24.7   21.4
lexeme         Text.Megaparsec.Lexer      Text/Megaparsec/Lexer.hs:87:1-23                        12.6   15.7
ops            Parser.Utils               src/Parser/Utils.hs:(69,1)-(74,3)                        2.6    2.7
toResult       Parser.Initial             src/Parser/Initial.hs:(62,1)-(79,29)                     2.3    2.2
run            Main                       app/Main.hs:(42,1)-(54,58)                               1.6    0.6
readTextDevice Data.Text.Internal.IO      libraries/text/src/Data/Text/Internal/IO.hs:133:39-64    1.3    0.0
</pre></table></code></div></div><p>Surprisingly, the vast majority of time (roughly 95%) is spent parsing. As such, we won’t worry ourselves about runtime any further.</p><h2 id="type-safety">Type Safety</h2><p>Let’s next explore how we can empower library users with a stricter version of the <code class="language-plaintext highlighter-rouge">Expr</code> monotype. In particular, we want to prohibit construction of invalid expressions. A common strategy is to promote our ADT to a GADT:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kr">data</span> <span class="kt">GExpr</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kt">GInt</span>  <span class="o">::</span> <span class="kt">Integer</span> <span class="o">-&gt;</span> <span class="kt">GExpr</span> <span class="kt">Integer</span>
  <span class="kt">GBool</span> <span class="o">::</span> <span class="kt">Bool</span>    <span class="o">-&gt;</span> <span class="kt">GExpr</span> <span class="kt">Bool</span>
  <span class="kt">GAdd</span>  <span class="o">::</span> <span class="kt">GExpr</span> <span class="kt">Integer</span> <span class="o">-&gt;</span> <span class="kt">GExpr</span> <span class="kt">Integer</span> <span class="o">-&gt;</span> <span class="kt">GExpr</span> <span class="kt">Integer</span>
  <span class="kt">GSub</span>  <span class="o">::</span> <span class="kt">GExpr</span> <span class="kt">Integer</span> <span class="o">-&gt;</span> <span class="kt">GExpr</span> <span class="kt">Integer</span> <span class="o">-&gt;</span> <span class="kt">GExpr</span> <span class="kt">Integer</span>
  <span class="kt">GAnd</span>  <span class="o">::</span> <span class="kt">GExpr</span> <span class="kt">Bool</span>    <span class="o">-&gt;</span> <span class="kt">GExpr</span> <span class="kt">Bool</span>    <span class="o">-&gt;</span> <span class="kt">GExpr</span> <span class="kt">Bool</span>
  <span class="kt">GOr</span>   <span class="o">::</span> <span class="kt">GExpr</span> <span class="kt">Bool</span>    <span class="o">-&gt;</span> <span class="kt">GExpr</span> <span class="kt">Bool</span>    <span class="o">-&gt;</span> <span class="kt">GExpr</span> <span class="kt">Bool</span>
</pre></table></code></div></div><p>By virtue of working with arbitrary, potentially mis-typed input, we must eventually perform <em>some</em> form of type-checking on our input. To get the GADT representation working requires additional machinery like existential datatypes and <code class="language-plaintext highlighter-rouge">Rank2Types</code>. The end user of our library reaps the benefits though, acquiring a strongly-typed representation of our AST:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kr">data</span> <span class="kt">Wrapper</span> <span class="o">=</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Show</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">Wrapper</span> <span class="p">(</span><span class="kt">GExpr</span> <span class="n">a</span><span class="p">)</span>

<span class="n">parseGadt</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Wrapper</span>
<span class="n">parseGadt</span> <span class="o">=</span> <span class="n">term</span> <span class="o">&gt;&gt;=</span> <span class="n">expr</span>
 <span class="kr">where</span>
  <span class="o">...</span>
  <span class="n">nest</span>
    <span class="o">::</span> <span class="n">forall</span> <span class="n">b</span>
     <span class="o">.</span> <span class="kt">Show</span> <span class="n">b</span>
    <span class="o">=&gt;</span> <span class="kt">Wrapper</span>
    <span class="o">-&gt;</span> <span class="p">(</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">GExpr</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Either</span> <span class="kt">Text</span> <span class="p">(</span><span class="kt">GExpr</span> <span class="n">b</span><span class="p">))</span>
    <span class="o">-&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">GExpr</span> <span class="n">b</span><span class="p">)</span>
    <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">GExpr</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">GExpr</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">GExpr</span> <span class="n">b</span><span class="p">)</span>
    <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="kt">Wrapper</span>
  <span class="n">nest</span> <span class="p">(</span><span class="kt">Wrapper</span> <span class="n">t</span><span class="p">)</span> <span class="n">cast</span> <span class="n">f</span> <span class="n">bin</span> <span class="o">=</span> <span class="kr">do</span>
    <span class="kt">Wrapper</span> <span class="n">t'</span> <span class="o">&lt;-</span> <span class="n">term</span>
    <span class="kr">case</span> <span class="p">(</span><span class="n">cast</span> <span class="n">t</span><span class="p">,</span> <span class="n">cast</span> <span class="n">t'</span><span class="p">)</span> <span class="kr">of</span>
      <span class="p">(</span><span class="kt">Right</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">Right</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kr">do</span>
        <span class="kr">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">eval</span> <span class="o">$</span> <span class="n">bin</span> <span class="n">lhs</span> <span class="n">rhs</span>
        <span class="n">z</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="n">expr</span> <span class="p">(</span><span class="kt">Wrapper</span> <span class="o">$</span> <span class="n">f</span> <span class="n">z</span><span class="p">)</span>
      <span class="p">(</span><span class="kt">Left</span> <span class="n">e</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">fail</span> <span class="o">$</span> <span class="n">unpack</span> <span class="n">e</span>
      <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="kt">Left</span> <span class="n">e</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">fail</span> <span class="o">$</span> <span class="n">unpack</span> <span class="n">e</span>
</pre></table></code></div></div><p>We hide the full details here (refer to the linked Github repository for the full implementation), but note the changes are minimal outside of the signatures/data types required to make our existentially quantified type work. Users of the parser can now unwrap the <code class="language-plaintext highlighter-rouge">Wrapper</code> type and resume like normal.</p><div class="alert alert-warning" role="alert"><div><i class="fa fa-exclamation-triangle"></i> <strong>Warning</strong></div><p>This is an arguable “improvement” considering <em>convenience</em> takes a dramatic hit. It is awkward working with the <code class="language-plaintext highlighter-rouge">Wrapper</code> type.</p></div><h2 id="expression-problem">Expression Problem</h2><p>Lastly comes the expression problem, and one that is fundamentally unsolvable given our current implementation. By nature of (G)ADTs, all data-types are <em>closed</em>. It is not extensible since that would break any static type guarantees around e.g. pattern matching. To fix this (and other problems still present in our implementation), we contrast our initial encoding to that of tagless final.</p><h1 id="tagless-final">Tagless Final</h1><p>Let’s re-think our GADT example above and refactor it into a typeclass:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kr">class</span> <span class="kt">Symantics</span> <span class="n">repr</span> <span class="kr">where</span>
  <span class="n">eInt</span>  <span class="o">::</span> <span class="kt">Integer</span> <span class="o">-&gt;</span> <span class="n">repr</span> <span class="kt">Integer</span>
  <span class="n">eBool</span> <span class="o">::</span> <span class="kt">Bool</span>    <span class="o">-&gt;</span> <span class="n">repr</span> <span class="kt">Bool</span>
  <span class="n">eAdd</span>  <span class="o">::</span> <span class="n">repr</span> <span class="kt">Integer</span> <span class="o">-&gt;</span> <span class="n">repr</span> <span class="kt">Integer</span> <span class="o">-&gt;</span> <span class="n">repr</span> <span class="kt">Integer</span>
  <span class="n">eSub</span>  <span class="o">::</span> <span class="n">repr</span> <span class="kt">Integer</span> <span class="o">-&gt;</span> <span class="n">repr</span> <span class="kt">Integer</span> <span class="o">-&gt;</span> <span class="n">repr</span> <span class="kt">Integer</span>
  <span class="n">eAnd</span>  <span class="o">::</span> <span class="n">repr</span> <span class="kt">Bool</span>    <span class="o">-&gt;</span> <span class="n">repr</span> <span class="kt">Bool</span>    <span class="o">-&gt;</span> <span class="n">repr</span> <span class="kt">Bool</span>
  <span class="n">eOr</span>   <span class="o">::</span> <span class="n">repr</span> <span class="kt">Bool</span>    <span class="o">-&gt;</span> <span class="n">repr</span> <span class="kt">Bool</span>    <span class="o">-&gt;</span> <span class="n">repr</span> <span class="kt">Bool</span>
</pre></table></code></div></div><p>This should look familiar. Instances of <code class="language-plaintext highlighter-rouge">GExpr</code> have been substituted by a parameter <code class="language-plaintext highlighter-rouge">repr</code> of kind <code class="language-plaintext highlighter-rouge">* -&gt; *</code>. Kiselyov describes typeclasses used this way as a means of defining a class of <em>interpreters</em>. An example interpreter could look like evaluation from before:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kr">newtype</span> <span class="kt">Eval</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Eval</span> <span class="p">{</span><span class="n">runEval</span> <span class="o">::</span> <span class="n">a</span><span class="p">}</span>

<span class="kr">instance</span> <span class="kt">Symantics</span> <span class="kt">Eval</span> <span class="kr">where</span>
  <span class="n">eInt</span>  <span class="o">=</span> <span class="kt">Eval</span>
  <span class="n">eBool</span> <span class="o">=</span> <span class="kt">Eval</span>
  <span class="n">eAdd</span> <span class="p">(</span><span class="kt">Eval</span> <span class="n">lhs</span><span class="p">)</span> <span class="p">(</span><span class="kt">Eval</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Eval</span> <span class="p">(</span><span class="n">lhs</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">)</span>
  <span class="n">eSub</span> <span class="p">(</span><span class="kt">Eval</span> <span class="n">lhs</span><span class="p">)</span> <span class="p">(</span><span class="kt">Eval</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Eval</span> <span class="p">(</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">)</span>
  <span class="n">eAnd</span> <span class="p">(</span><span class="kt">Eval</span> <span class="n">lhs</span><span class="p">)</span> <span class="p">(</span><span class="kt">Eval</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Eval</span> <span class="p">(</span><span class="n">lhs</span> <span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span>
  <span class="n">eOr</span>  <span class="p">(</span><span class="kt">Eval</span> <span class="n">lhs</span><span class="p">)</span> <span class="p">(</span><span class="kt">Eval</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Eval</span> <span class="p">(</span><span class="n">lhs</span> <span class="o">||</span> <span class="n">rhs</span><span class="p">)</span>
</pre></table></code></div></div><p>To belabor the similarities between the two a bit further, compare the following two examples side-by-side:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kr">let</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">foldl'</span> <span class="n">eAdd</span> <span class="p">(</span><span class="n">eInt</span> <span class="mi">0</span><span class="p">)</span> <span class="o">$</span> <span class="n">take</span> <span class="n">count</span> <span class="p">(</span><span class="n">eInt</span> <span class="o">&lt;$&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">])</span>
<span class="kr">let</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">foldl'</span> <span class="kt">EAdd</span> <span class="p">(</span><span class="kt">EInt</span> <span class="mi">0</span><span class="p">)</span> <span class="o">$</span> <span class="n">take</span> <span class="n">count</span> <span class="p">(</span><span class="kt">EInt</span> <span class="o">&lt;$&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">])</span>
</pre></table></code></div></div><p>Outside of some capitalization, the encodings are exactly the same. Considering these similarities, it’s clear type safety is not a concern like it was with <code class="language-plaintext highlighter-rouge">Expr</code>. This new paradigm also allows us to write both an implementation that parallels the memory usage <a href="#resource-usage">of above</a> as well as a proper solution to the expression problem. To follow along though first requires a quick detour into <strong>leibniz equalities</strong>.</p><h2 id="leibniz-equality">Leibniz Equality</h2><p>Leibniz equality states that two objects are equivalent provided they can be substituted in all contexts without issue. Consider the definition provided by the <a href="https://hackage.haskell.org/package/eq">eq</a> package:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kr">newtype</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">Refl</span> <span class="p">{</span><span class="n">subst</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">c</span><span class="o">.</span> <span class="n">c</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span> <span class="n">b</span><span class="p">}</span>
</pre></table></code></div></div><p>Here we are saying two types <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> actually refer to the same type if it turns out that simultaneously</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="err">•</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="o">~</span> <span class="kt">Maybe</span> <span class="n">b</span>
<span class="err">•</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="n">a</span> <span class="o">~</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="n">b</span>
<span class="err">•</span> <span class="kt">Identity</span> <span class="n">a</span> <span class="o">~</span> <span class="kt">Identity</span> <span class="n">b</span>
<span class="err">•</span> <span class="o">...</span>
</pre></table></code></div></div><p>and so on, where <code class="language-plaintext highlighter-rouge">~</code> refers to <a href="https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/equality-constraints.html">equality constraints</a>. Let’s clarify further with an example. Suppose we had types <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> and wanted to ensure they were actually the same type. Then there must exist a function <code class="language-plaintext highlighter-rouge">subst</code> with signature <code class="language-plaintext highlighter-rouge">c A -&gt; c B</code> <em>for all</em> <code class="language-plaintext highlighter-rouge">c</code>. What might that function look like? It turns out there is only one acceptable choice: <code class="language-plaintext highlighter-rouge">id</code>.</p><p>This might not seem particularly valuable at first glance, but what it does permit is a means of <em>proving</em> equality at the type-level and in a way Haskell’s type system respects. For instance, the following is valid:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kr">import</span> <span class="nn">Data.Eq.Type</span> <span class="p">((</span><span class="o">:=</span><span class="p">)(</span><span class="o">..</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="o">:</span><span class="n">set</span> <span class="o">-</span><span class="kt">XTypeOperators</span>

<span class="c1">-- Type-level equality is reflexive. I can prove it since</span>
<span class="c1">-- `id` is a suitable candidate for `subst`.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">refl</span> <span class="o">=</span> <span class="kt">Refl</span> <span class="n">id</span>
<span class="o">&gt;&gt;&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">refl</span>
<span class="n">refl</span> <span class="o">::</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">b</span>

<span class="c1">-- Haskell can verify our types truly are the same.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">refl</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Integer</span> <span class="o">:=</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">refl</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Integer</span> <span class="o">:=</span> <span class="kt">Bool</span><span class="p">)</span>

<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">7</span><span class="o">:</span><span class="mi">5</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span>
    <span class="err">•</span> <span class="kt">Couldn't</span> <span class="n">match</span> <span class="kr">type</span> <span class="err">‘</span><span class="kt">Integer</span><span class="err">’</span> <span class="n">with</span> <span class="err">‘</span><span class="kt">Bool</span><span class="err">’</span>
</pre></table></code></div></div><p>We can also prove less obvious things at the type-level and take advantage of this later on. As an exercise, consider how you might express the following:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">functionEquality</span>
  <span class="o">::</span> <span class="n">a1</span> <span class="o">:=</span> <span class="n">a2</span>
  <span class="o">-&gt;</span> <span class="n">b1</span> <span class="o">:=</span> <span class="n">b2</span>
  <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a1</span> <span class="o">-&gt;</span> <span class="n">b1</span><span class="p">)</span> <span class="o">:=</span> <span class="p">(</span><span class="n">a2</span> <span class="o">-&gt;</span> <span class="n">b2</span><span class="p">)</span>
</pre></table></code></div></div><p>That is, if <code class="language-plaintext highlighter-rouge">a1</code> and <code class="language-plaintext highlighter-rouge">a2</code> are the same types, and <code class="language-plaintext highlighter-rouge">b1</code> and <code class="language-plaintext highlighter-rouge">b2</code> are the same types, then functions of type <code class="language-plaintext highlighter-rouge">a1 -&gt; b1</code> can equivalently be expressed as functions from <code class="language-plaintext highlighter-rouge">a2 -&gt; b2</code>.</p><details style="border: 1px dashed rgba(155, 155, 155, 0.8); padding: 6px;"> <summary> <strong>Answer</strong> </summary><div style="padding-top: 12px;"><p>I suggest reading from the bottom up to better understand why this works.</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kr">import</span> <span class="nn">Data.Eq.Type</span> <span class="p">((</span><span class="o">:=</span><span class="p">)(</span><span class="o">..</span><span class="p">),</span> <span class="nf">refl</span><span class="p">)</span>

<span class="kr">newtype</span> <span class="kt">F1</span> <span class="n">t</span> <span class="n">b</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">F1</span> <span class="p">{</span><span class="n">runF1</span> <span class="o">::</span> <span class="n">t</span> <span class="o">:=</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)}</span>
<span class="kr">newtype</span> <span class="kt">F2</span> <span class="n">t</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">F2</span> <span class="p">{</span><span class="n">runF2</span> <span class="o">::</span> <span class="n">t</span> <span class="o">:=</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)}</span>

<span class="n">functionEquality</span>
  <span class="o">::</span> <span class="n">forall</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">b1</span> <span class="n">b2</span>
   <span class="o">.</span> <span class="n">a1</span> <span class="o">:=</span> <span class="n">a2</span>
  <span class="o">-&gt;</span> <span class="n">b1</span> <span class="o">:=</span> <span class="n">b2</span>
  <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a1</span> <span class="o">-&gt;</span> <span class="n">b1</span><span class="p">)</span> <span class="o">:=</span> <span class="p">(</span><span class="n">a2</span> <span class="o">-&gt;</span> <span class="n">b2</span><span class="p">)</span>
<span class="n">functionEquality</span>
  <span class="p">(</span><span class="kt">Refl</span> <span class="n">s1</span><span class="p">)</span>  <span class="c1">-- s1 :: forall c. c a1 -&gt; c a2</span>
  <span class="p">(</span><span class="kt">Refl</span> <span class="n">s2</span><span class="p">)</span>  <span class="c1">-- s2 :: forall c. c b1 -&gt; c b2</span>
  <span class="o">=</span> <span class="n">runF2</span>    <span class="c1">-- (a1 -&gt; b1) := (a2 -&gt; b2)</span>
  <span class="o">.</span> <span class="n">s2</span>       <span class="c1">-- F2 (a1 -&gt; b1) a2 b2</span>
  <span class="o">.</span> <span class="kt">F2</span>       <span class="c1">-- F2 (a1 -&gt; b1) a2 b1</span>
  <span class="o">.</span> <span class="n">runF1</span>    <span class="c1">-- (a1 -&gt; b1) := (a2 -&gt; b1)</span>
  <span class="o">.</span> <span class="n">s1</span>       <span class="c1">-- F1 (a1 -&gt; b1) b1 a2</span>
  <span class="o">.</span> <span class="kt">F1</span>       <span class="c1">-- F1 (a1 -&gt; b1) b1 a1</span>
  <span class="o">$</span> <span class="n">refl</span>     <span class="c1">-- (a1 -&gt; b1) := (a1 -&gt; b1)</span>
</pre></table></code></div></div></div></details><h2 id="dynamics">Dynamics</h2><p>Within our GADTs example, we introduced data type <code class="language-plaintext highlighter-rouge">Wrapper</code> to allow us to pass around GADTs of internally different type (e.g. <code class="language-plaintext highlighter-rouge">GExpr Integer</code> vs. <code class="language-plaintext highlighter-rouge">GExpr Bool</code>) within the same context. We can do something similar via <code class="language-plaintext highlighter-rouge">Dynamics</code> in the tagless final world. Though we could use the already available <a href="https://hackage.haskell.org/package/base-4.16.0.0/docs/Data-Dynamic.html">dynamics</a> library, we’ll build our own for exploration’s sake.</p><p>First, let’s create a representation of the types in our grammar:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kr">class</span> <span class="kt">Typeable</span> <span class="n">repr</span> <span class="kr">where</span>
  <span class="n">pInt</span>  <span class="o">::</span> <span class="n">repr</span> <span class="kt">Integer</span>
  <span class="n">pBool</span> <span class="o">::</span> <span class="n">repr</span> <span class="kt">Bool</span>

<span class="kr">newtype</span> <span class="kt">TQ</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">TQ</span> <span class="p">{</span><span class="n">runTQ</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">repr</span><span class="o">.</span> <span class="kt">Typeable</span> <span class="n">repr</span> <span class="o">=&gt;</span> <span class="n">repr</span> <span class="n">t</span><span class="p">}</span>

<span class="kr">instance</span> <span class="kt">Typeable</span> <span class="kt">TQ</span> <span class="kr">where</span>
  <span class="n">pInt</span>  <span class="o">=</span> <span class="kt">TQ</span> <span class="n">pInt</span>
  <span class="n">pBool</span> <span class="o">=</span> <span class="kt">TQ</span> <span class="n">pBool</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">TQ</code> takes advantage of polymorphic constructors to allow us to wrap any compatible <code class="language-plaintext highlighter-rouge">Typeable</code> member function and “reinterpret” it as something else. For example, we can create new <code class="language-plaintext highlighter-rouge">Typeable</code> instances like so:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kr">newtype</span> <span class="kt">AsInt</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">AsInt</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="p">(</span><span class="n">a</span> <span class="o">:=</span> <span class="kt">Integer</span><span class="p">))</span>

<span class="kr">instance</span> <span class="kt">Typeable</span> <span class="kt">AsInt</span> <span class="kr">where</span>
  <span class="n">pInt</span>  <span class="o">=</span> <span class="kt">AsInt</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">refl</span><span class="p">)</span>
  <span class="n">pBool</span> <span class="o">=</span> <span class="kt">AsInt</span> <span class="kt">Nothing</span>

<span class="kr">newtype</span> <span class="kt">AsBool</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">AsBool</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="p">(</span><span class="n">a</span> <span class="o">:=</span> <span class="kt">Bool</span><span class="p">))</span>

<span class="kr">instance</span> <span class="kt">Typeable</span> <span class="kt">AsBool</span> <span class="kr">where</span>
  <span class="n">pInt</span>  <span class="o">=</span> <span class="kt">AsBool</span> <span class="kt">Nothing</span>
  <span class="n">pBool</span> <span class="o">=</span> <span class="kt">AsBool</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">refl</span><span class="p">)</span>
</pre></table></code></div></div><p>We can then use <code class="language-plaintext highlighter-rouge">TQ</code> to check if something is of the appropriate type:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kr">import</span> <span class="nn">Data.Maybe</span> <span class="p">(</span><span class="nf">isJust</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">tq</span> <span class="o">=</span> <span class="n">pInt</span> <span class="o">::</span> <span class="kt">TQ</span> <span class="kt">Integer</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kr">case</span> <span class="n">runTQ</span> <span class="n">tq</span> <span class="kr">of</span> <span class="kt">AsInt</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">isJust</span> <span class="n">a</span>
<span class="kt">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kr">case</span> <span class="n">runTQ</span> <span class="n">tq</span> <span class="kr">of</span> <span class="kt">AsBool</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">isJust</span> <span class="n">a</span>
<span class="kt">False</span>
</pre></table></code></div></div><p>Even more interestingly, we can bundle this type representation alongside a value of the corresponding type, yielding our desired <code class="language-plaintext highlighter-rouge">Dynamic</code>:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Eq.Type</span> <span class="k">as</span> <span class="n">EQ</span>

<span class="kr">data</span> <span class="kt">Dynamic</span> <span class="n">repr</span> <span class="o">=</span> <span class="n">forall</span> <span class="n">t</span><span class="o">.</span> <span class="kt">Dynamic</span> <span class="p">(</span><span class="kt">TQ</span> <span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="n">repr</span> <span class="n">t</span><span class="p">)</span>

<span class="kr">class</span> <span class="kt">IsDynamic</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">type'</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">repr</span><span class="o">.</span> <span class="kt">Typeable</span> <span class="n">repr</span> <span class="o">=&gt;</span> <span class="n">repr</span> <span class="n">a</span>
  <span class="n">lift'</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">repr</span><span class="o">.</span> <span class="kt">Symantics</span> <span class="n">repr</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">repr</span> <span class="n">a</span>
  <span class="n">cast'</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">repr</span> <span class="n">t</span><span class="o">.</span> <span class="kt">TQ</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="n">t</span> <span class="o">:=</span> <span class="n">a</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">IsDynamic</span> <span class="kt">Integer</span> <span class="kr">where</span>
  <span class="n">type'</span> <span class="o">=</span> <span class="n">pInt</span>
  <span class="n">lift'</span> <span class="o">=</span> <span class="n">eInt</span>
  <span class="n">cast'</span> <span class="p">(</span><span class="kt">TQ</span> <span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="kr">case</span> <span class="n">t</span> <span class="kr">of</span> <span class="kt">AsInt</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>

<span class="kr">instance</span> <span class="kt">IsDynamic</span> <span class="kt">Bool</span> <span class="kr">where</span>
  <span class="n">type'</span> <span class="o">=</span> <span class="n">pBool</span>
  <span class="n">lift'</span> <span class="o">=</span> <span class="n">eBool</span>
  <span class="n">cast'</span> <span class="p">(</span><span class="kt">TQ</span> <span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="kr">case</span> <span class="n">t</span> <span class="kr">of</span> <span class="kt">AsBool</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>

<span class="n">toDyn</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">repr</span> <span class="n">a</span><span class="o">.</span> <span class="kt">IsDynamic</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">Symantics</span> <span class="n">repr</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Dynamic</span> <span class="n">repr</span>
<span class="n">toDyn</span> <span class="o">=</span> <span class="kt">Dynamic</span> <span class="n">type'</span> <span class="o">.</span> <span class="n">lift'</span>

<span class="n">fromDyn</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">repr</span> <span class="n">a</span><span class="o">.</span> <span class="kt">IsDynamic</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">Dynamic</span> <span class="n">repr</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="n">repr</span> <span class="n">a</span><span class="p">)</span>
<span class="n">fromDyn</span> <span class="p">(</span><span class="kt">Dynamic</span> <span class="n">t</span> <span class="n">e</span><span class="p">)</span> <span class="o">=</span> <span class="kr">case</span> <span class="n">t</span> <span class="kr">of</span>
  <span class="p">(</span><span class="n">cast'</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kr">do</span>
    <span class="n">r'</span> <span class="o">&lt;-</span> <span class="n">r</span>
    <span class="n">pure</span> <span class="o">$</span> <span class="kt">EQ</span><span class="o">.</span><span class="n">coerce</span> <span class="p">(</span><span class="kt">EQ</span><span class="o">.</span><span class="n">lift</span> <span class="n">r'</span><span class="p">)</span> <span class="n">e</span>
</pre></table></code></div></div><hr /><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">toDyn</span> <span class="mi">5</span>           <span class="o">::</span> <span class="kt">Dynamic</span> <span class="kt">Expr</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">runExpr</span> <span class="o">&lt;$&gt;</span> <span class="n">fromDyn</span> <span class="n">a</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="kt">Integer</span>
<span class="kt">Just</span> <span class="mi">5</span>
</pre></table></code></div></div><p>By maintaining a leibniz equality within our <code class="language-plaintext highlighter-rouge">Dynamic</code> instances (i.e. <code class="language-plaintext highlighter-rouge">AsInt</code>), we can internally coerce the wrapped value into the actual type we care about. With this background information in place, we can finally devise an expression parser similar to the parser we’ve written using initial encoding:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="n">parseStrict</span>
  <span class="o">::</span> <span class="n">forall</span> <span class="n">repr</span>
   <span class="o">.</span> <span class="kt">NFData</span> <span class="p">(</span><span class="kt">Dynamic</span> <span class="n">repr</span><span class="p">)</span>
  <span class="o">=&gt;</span> <span class="kt">Symantics</span> <span class="n">repr</span>
  <span class="o">=&gt;</span> <span class="kt">Parser</span> <span class="p">(</span><span class="kt">Dynamic</span> <span class="n">repr</span><span class="p">)</span>
<span class="n">parseStrict</span> <span class="o">=</span> <span class="n">term</span> <span class="o">&gt;&gt;=</span> <span class="n">expr</span>
 <span class="kr">where</span>
  <span class="n">expr</span> <span class="o">::</span> <span class="kt">Dynamic</span> <span class="n">repr</span> <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="p">(</span><span class="kt">Dynamic</span> <span class="n">repr</span><span class="p">)</span>
  <span class="n">expr</span> <span class="n">t</span> <span class="o">=</span> <span class="kr">do</span>
    <span class="n">op</span> <span class="o">&lt;-</span> <span class="kt">M</span><span class="o">.</span><span class="n">option</span> <span class="kt">Nothing</span> <span class="o">$</span> <span class="kt">Just</span> <span class="o">&lt;$&gt;</span> <span class="n">ops</span>
    <span class="kr">case</span> <span class="n">op</span> <span class="kr">of</span>
      <span class="kt">Just</span> <span class="kt">OpAdd</span> <span class="o">-&gt;</span> <span class="n">nest</span> <span class="n">t</span> <span class="n">eAdd</span> <span class="kt">OpAdd</span>
      <span class="kt">Just</span> <span class="kt">OpSub</span> <span class="o">-&gt;</span> <span class="n">nest</span> <span class="n">t</span> <span class="n">eSub</span> <span class="kt">OpSub</span>
      <span class="kt">Just</span> <span class="kt">OpAnd</span> <span class="o">-&gt;</span> <span class="n">nest</span> <span class="n">t</span> <span class="n">eAnd</span> <span class="kt">OpAnd</span>
      <span class="kt">Just</span> <span class="kt">OpOr</span>  <span class="o">-&gt;</span> <span class="n">nest</span> <span class="n">t</span> <span class="n">eOr</span>  <span class="kt">OpOr</span>
      <span class="kr">_</span>          <span class="o">-&gt;</span> <span class="n">pure</span> <span class="n">t</span>

  <span class="n">nest</span>
    <span class="o">::</span> <span class="n">forall</span> <span class="n">a</span>
     <span class="o">.</span> <span class="kt">IsDynamic</span> <span class="n">a</span>
    <span class="o">=&gt;</span> <span class="kt">Dynamic</span> <span class="n">repr</span>
    <span class="o">-&gt;</span> <span class="p">(</span><span class="n">repr</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">repr</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">repr</span> <span class="n">a</span><span class="p">)</span>
    <span class="o">-&gt;</span> <span class="kt">Op</span>
    <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="p">(</span><span class="kt">Dynamic</span> <span class="n">repr</span><span class="p">)</span>
  <span class="n">nest</span> <span class="n">t</span> <span class="n">bin</span> <span class="n">op</span> <span class="o">=</span> <span class="kr">do</span>
    <span class="n">t'</span> <span class="o">&lt;-</span> <span class="n">term</span>
    <span class="kr">case</span> <span class="n">binDyn</span> <span class="n">bin</span> <span class="n">t</span> <span class="n">t'</span> <span class="kr">of</span>
      <span class="kt">Nothing</span> <span class="o">-&gt;</span> <span class="n">fail</span> <span class="o">$</span> <span class="s">"Invalid operands for `"</span> <span class="o">&lt;&gt;</span> <span class="n">show</span> <span class="n">op</span> <span class="o">&lt;&gt;</span> <span class="s">"`"</span>
      <span class="kt">Just</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="p">`</span><span class="n">deepseq</span><span class="p">`</span> <span class="n">expr</span> <span class="n">a</span>

  <span class="n">term</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="p">(</span><span class="kt">Dynamic</span> <span class="n">repr</span><span class="p">)</span>
  <span class="n">term</span> <span class="o">=</span> <span class="kr">do</span>
    <span class="n">p</span> <span class="o">&lt;-</span> <span class="kt">M</span><span class="o">.</span><span class="n">option</span> <span class="kt">Nothing</span> <span class="o">$</span> <span class="kt">Just</span> <span class="o">&lt;$&gt;</span> <span class="n">symbol</span> <span class="s">"("</span>
    <span class="kr">if</span> <span class="n">isJust</span> <span class="n">p</span> <span class="kr">then</span> <span class="p">(</span><span class="n">term</span> <span class="o">&gt;&gt;=</span> <span class="n">expr</span><span class="p">)</span> <span class="o">&lt;*</span> <span class="n">symbol</span> <span class="s">")"</span> <span class="kr">else</span>
      <span class="n">toDyn</span> <span class="o">&lt;$&gt;</span> <span class="n">integer</span> <span class="o">&lt;|&gt;</span> <span class="n">toDyn</span> <span class="o">&lt;$&gt;</span> <span class="n">boolean</span>
</pre></table></code></div></div><h2 id="interpretations">Interpretations</h2><p>So far we’ve seen very little benefit switching to this strategy despite the level of complexity this change introduces. Here we’ll pose a question that hopefully makes at least one benefit more obvious. Suppose we wanted to interpret the parsed expression in two different ways. First, we want a basic evaluator, and second we want a pretty-printer. In our initial encoding strategy, the evaluator has already been defined:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">eval</span> <span class="o">::</span> <span class="kt">GExpr</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
</pre></table></code></div></div><p>We say <code class="language-plaintext highlighter-rouge">eval</code> is one possible interpreter over <code class="language-plaintext highlighter-rouge">GExpr</code>. It takes in <code class="language-plaintext highlighter-rouge">GExpr</code>s and reduces them into literal values. How would a pretty printer work? One candidate interpreter could look as follows:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">pPrint</span> <span class="o">::</span> <span class="kt">GExpr</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Text</span>
<span class="n">pPrint</span> <span class="p">(</span><span class="kt">GInt</span> <span class="n">e</span><span class="p">)</span>  <span class="o">=</span> <span class="n">pack</span> <span class="o">$</span> <span class="n">show</span> <span class="n">e</span>
<span class="n">pPrint</span> <span class="p">(</span><span class="kt">GBool</span> <span class="n">e</span><span class="p">)</span> <span class="o">=</span> <span class="n">pack</span> <span class="o">$</span> <span class="n">show</span> <span class="n">e</span>
<span class="n">pPrint</span> <span class="p">(</span><span class="kt">GAdd</span> <span class="n">lhs</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="s">"("</span> <span class="o">&lt;&gt;</span> <span class="n">pPrint</span> <span class="n">lhs</span> <span class="o">&lt;&gt;</span> <span class="s">" + "</span> <span class="o">&lt;&gt;</span> <span class="n">pPrint</span> <span class="n">rhs</span> <span class="o">&lt;&gt;</span> <span class="s">")"</span>
<span class="o">...</span>
</pre></table></code></div></div><p>Unfortunately using this definition requires fundamentally changing how our GADT parser works. <code class="language-plaintext highlighter-rouge">parseGadt</code> currently makes certain optimizations based on the fact only <code class="language-plaintext highlighter-rouge">eval</code> has been needed so far, reducing the expression as we traverse the input stream. Generalizing the parser to take in any function of signature <code class="language-plaintext highlighter-rouge">forall b. (forall a. GExpr a) -&gt; b</code> (i.e. the signature of some generic interpreter) would force us to retain memory or accept additional arguments to make our function especially generic to accommodate.<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></p><p>On the other hand, our tagless final approach expects multiple interpretations from the outset. We can define a <code class="language-plaintext highlighter-rouge">newtype</code> like</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kr">newtype</span> <span class="kt">PPrint</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">PPrint</span> <span class="p">{</span><span class="n">runPPrint</span> <span class="o">::</span> <span class="n">a</span><span class="p">}</span>

<span class="kr">instance</span> <span class="kt">Symantics</span> <span class="kt">PPrint</span> <span class="kr">where</span>
  <span class="n">eInt</span>  <span class="o">=</span> <span class="kt">PPrint</span> <span class="o">.</span> <span class="n">pack</span> <span class="o">.</span> <span class="n">show</span>
  <span class="n">eBool</span> <span class="o">=</span> <span class="kt">PPrint</span> <span class="o">.</span> <span class="n">pack</span> <span class="o">.</span> <span class="n">show</span>
  <span class="n">eAdd</span> <span class="p">(</span><span class="kt">PPrint</span> <span class="n">lhs</span><span class="p">)</span> <span class="p">(</span><span class="kt">PPrint</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="kt">PPrint</span> <span class="o">$</span> <span class="s">"("</span> <span class="o">&lt;&gt;</span> <span class="n">lhs</span> <span class="o">&lt;&gt;</span> <span class="s">" + "</span> <span class="o">&lt;&gt;</span> <span class="n">rhs</span> <span class="o">&lt;&gt;</span> <span class="s">")"</span>
  <span class="o">...</span>
</pre></table></code></div></div><p>and interpret our</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">parseStrict</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">repr</span><span class="o">.</span> <span class="kt">Symantics</span> <span class="n">repr</span> <span class="o">=&gt;</span> <span class="kt">Parser</span> <span class="p">(</span><span class="kt">Dynamic</span> <span class="n">repr</span><span class="p">)</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">Parser</code> as a <code class="language-plaintext highlighter-rouge">Dynamic PPrint</code> instead of a <code class="language-plaintext highlighter-rouge">Dynamic Eval</code> without losing any previously acquired gains.</p><h2 id="expression-revisited">Expression Revisited</h2><p>There does exist a major caveat with our tagless final interpreters. If owning a single <code class="language-plaintext highlighter-rouge">Dynamic</code> instance, how exactly are we able to interpret this in multiple ways? After all, a <code class="language-plaintext highlighter-rouge">Dynamic</code> cannot be of type <code class="language-plaintext highlighter-rouge">Dynamic Eval</code> <em>and</em> <code class="language-plaintext highlighter-rouge">Dynamic PPrint</code>. What we’d like to be able to do is maintain a generic <code class="language-plaintext highlighter-rouge">Dynamic repr</code> and reinterpret it at will.</p><p>One solution comes in the form of another <code class="language-plaintext highlighter-rouge">newtype</code> around a polymorphic constructor:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kr">newtype</span> <span class="kt">SQ</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">SQ</span> <span class="p">{</span><span class="n">runSQ</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">repr</span><span class="o">.</span> <span class="kt">Symantics</span> <span class="n">repr</span> <span class="o">=&gt;</span> <span class="n">repr</span> <span class="n">a</span><span class="p">}</span>

<span class="kr">instance</span> <span class="kt">Symantics</span> <span class="kt">SQ</span> <span class="kr">where</span>
  <span class="n">eInt</span>  <span class="n">e</span> <span class="o">=</span> <span class="kt">SQ</span> <span class="p">(</span><span class="n">eInt</span> <span class="n">e</span><span class="p">)</span>
  <span class="n">eBool</span> <span class="n">e</span> <span class="o">=</span> <span class="kt">SQ</span> <span class="p">(</span><span class="n">eBool</span> <span class="n">e</span><span class="p">)</span>
  <span class="n">eAdd</span> <span class="p">(</span><span class="kt">SQ</span> <span class="n">lhs</span><span class="p">)</span> <span class="p">(</span><span class="kt">SQ</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="kt">SQ</span> <span class="p">(</span><span class="n">eAdd</span> <span class="n">lhs</span> <span class="n">rhs</span><span class="p">)</span>
  <span class="n">eSub</span> <span class="p">(</span><span class="kt">SQ</span> <span class="n">lhs</span><span class="p">)</span> <span class="p">(</span><span class="kt">SQ</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="kt">SQ</span> <span class="p">(</span><span class="n">eSub</span> <span class="n">lhs</span> <span class="n">rhs</span><span class="p">)</span>
  <span class="n">eAnd</span> <span class="p">(</span><span class="kt">SQ</span> <span class="n">lhs</span><span class="p">)</span> <span class="p">(</span><span class="kt">SQ</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="kt">SQ</span> <span class="p">(</span><span class="n">eAnd</span> <span class="n">lhs</span> <span class="n">rhs</span><span class="p">)</span>
  <span class="n">eOr</span>  <span class="p">(</span><span class="kt">SQ</span> <span class="n">lhs</span><span class="p">)</span> <span class="p">(</span><span class="kt">SQ</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="kt">SQ</span> <span class="p">(</span><span class="n">eOr</span>  <span class="n">lhs</span> <span class="n">rhs</span><span class="p">)</span>
</pre></table></code></div></div><p>We can then run evaluation and pretty-printing on the same entity:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kr">data</span> <span class="kt">Result</span> <span class="o">=</span> <span class="kt">RInt</span> <span class="kt">Integer</span> <span class="o">|</span> <span class="kt">RBool</span> <span class="kt">Bool</span>

<span class="n">runBoth</span> <span class="o">::</span> <span class="kt">Dynamic</span> <span class="kt">SQ</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Result</span><span class="p">,</span> <span class="kt">Text</span><span class="p">)</span>
<span class="n">runBoth</span> <span class="n">d</span> <span class="o">=</span> <span class="kr">case</span> <span class="n">fromDyn</span> <span class="n">d</span> <span class="kr">of</span>
  <span class="kt">Just</span> <span class="p">(</span><span class="kt">SQ</span> <span class="n">q</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pure</span> <span class="p">(</span> <span class="kr">case</span> <span class="n">q</span> <span class="kr">of</span> <span class="kt">Eval</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">RInt</span> <span class="n">a</span>
                      <span class="p">,</span> <span class="kr">case</span> <span class="n">q</span> <span class="kr">of</span> <span class="kt">PPrint</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
                      <span class="p">)</span>
  <span class="kt">Nothing</span> <span class="o">-&gt;</span> <span class="kr">case</span> <span class="n">fromDyn</span> <span class="n">d</span> <span class="kr">of</span>
    <span class="kt">Just</span> <span class="p">(</span><span class="kt">SQ</span> <span class="n">q</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pure</span> <span class="p">(</span> <span class="kr">case</span> <span class="n">q</span> <span class="kr">of</span> <span class="kt">Eval</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">RBool</span> <span class="n">a</span>
                        <span class="p">,</span> <span class="kr">case</span> <span class="n">q</span> <span class="kr">of</span> <span class="kt">PPrint</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
                        <span class="p">)</span>
    <span class="kt">Nothing</span> <span class="o">-&gt;</span> <span class="kt">Nothing</span>
</pre></table></code></div></div><p>This has an unintended side effect though. By using <code class="language-plaintext highlighter-rouge">SQ</code>, we effectively close our type universe. Suppose we now wanted to extend our <code class="language-plaintext highlighter-rouge">Symantics</code> type with a new multiplication operator (<code class="language-plaintext highlighter-rouge">*</code>). We could do so by writing typeclass:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kr">class</span> <span class="kt">MulSymantics</span> <span class="n">repr</span> <span class="kr">where</span>
  <span class="n">eMul</span> <span class="o">::</span> <span class="n">repr</span> <span class="kt">Integer</span> <span class="o">-&gt;</span> <span class="n">repr</span> <span class="kt">Integer</span> <span class="o">-&gt;</span> <span class="n">repr</span> <span class="kt">Integer</span>

<span class="kr">instance</span> <span class="kt">MulSymantics</span> <span class="kt">Eval</span> <span class="kr">where</span>
  <span class="n">eMul</span> <span class="p">(</span><span class="kt">Eval</span> <span class="n">lhs</span><span class="p">)</span> <span class="p">(</span><span class="kt">Eval</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Eval</span> <span class="p">(</span><span class="n">lhs</span> <span class="o">*</span> <span class="n">rhs</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">MulSymantics</span> <span class="kt">PPrint</span> <span class="kr">where</span>
  <span class="n">eMul</span> <span class="p">(</span><span class="kt">PPrint</span> <span class="n">lhs</span><span class="p">)</span> <span class="p">(</span><span class="kt">PPrint</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="kt">PPrint</span> <span class="o">$</span> <span class="s">"("</span> <span class="o">&lt;&gt;</span> <span class="n">lhs</span> <span class="o">&lt;&gt;</span> <span class="s">" * "</span> <span class="o">&lt;&gt;</span> <span class="n">rhs</span> <span class="o">&lt;&gt;</span> <span class="s">")"</span>
</pre></table></code></div></div><div class="alert alert-warning" role="alert"><div><i class="fa fa-exclamation-triangle"></i> <strong>Warning</strong></div><p>Naturally we also need to extend our parser to be aware of the new operator as well. To avoid diving yet further into the weeds, we do not do that here.</p></div><p>But this typeclass is excluded from our <code class="language-plaintext highlighter-rouge">SQ</code> type. We’re forced to write yet another <code class="language-plaintext highlighter-rouge">SQ</code>-like wrapper, e.g.</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kr">newtype</span> <span class="kt">MSQ</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">MSQ</span> <span class="p">{</span><span class="n">runMSQ</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">repr</span><span class="o">.</span> <span class="kt">MulSymantics</span> <span class="n">repr</span> <span class="o">=&gt;</span> <span class="n">repr</span> <span class="n">a</span><span class="p">}</span>
</pre></table></code></div></div><p>just to keep up. This in turn forces us to redefine all functions that operated on <code class="language-plaintext highlighter-rouge">SQ</code>.</p><h3 id="copy-symantics">Copy Symantics</h3><p>We can reformulate this more openly, abandoning any sort of <code class="language-plaintext highlighter-rouge">Rank2</code> constructors within our <code class="language-plaintext highlighter-rouge">newtype</code>s by choosing to track multiple representations simultaneously:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kr">data</span> <span class="kt">SCopy</span> <span class="n">repr1</span> <span class="n">repr2</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">SCopy</span> <span class="p">(</span><span class="n">repr1</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">repr2</span> <span class="n">a</span><span class="p">)</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Symantics</span> <span class="n">repr1</span><span class="p">,</span> <span class="kt">Symantics</span> <span class="n">repr2</span><span class="p">)</span>
  <span class="o">=&gt;</span> <span class="kt">Symantics</span> <span class="p">(</span><span class="kt">SCopy</span> <span class="n">repr1</span> <span class="n">repr2</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">eInt</span> <span class="n">e</span>  <span class="o">=</span> <span class="kt">SCopy</span> <span class="p">(</span><span class="n">eInt</span> <span class="n">e</span><span class="p">)</span> <span class="p">(</span><span class="n">eInt</span> <span class="n">e</span><span class="p">)</span>
  <span class="n">eBool</span> <span class="n">e</span> <span class="o">=</span> <span class="kt">SCopy</span> <span class="p">(</span><span class="n">eBool</span> <span class="n">e</span><span class="p">)</span> <span class="p">(</span><span class="n">eBool</span> <span class="n">e</span><span class="p">)</span>
  <span class="n">eAdd</span> <span class="p">(</span><span class="kt">SCopy</span> <span class="n">a1</span> <span class="n">a2</span><span class="p">)</span> <span class="p">(</span><span class="kt">SCopy</span> <span class="n">b1</span> <span class="n">b2</span><span class="p">)</span> <span class="o">=</span> <span class="kt">SCopy</span> <span class="p">(</span><span class="n">eAdd</span> <span class="n">a1</span> <span class="n">b1</span><span class="p">)</span> <span class="p">(</span><span class="n">eAdd</span> <span class="n">a2</span> <span class="n">b2</span><span class="p">)</span>
  <span class="n">eSub</span> <span class="p">(</span><span class="kt">SCopy</span> <span class="n">a1</span> <span class="n">a2</span><span class="p">)</span> <span class="p">(</span><span class="kt">SCopy</span> <span class="n">b1</span> <span class="n">b2</span><span class="p">)</span> <span class="o">=</span> <span class="kt">SCopy</span> <span class="p">(</span><span class="n">eSub</span> <span class="n">a1</span> <span class="n">b1</span><span class="p">)</span> <span class="p">(</span><span class="n">eSub</span> <span class="n">a2</span> <span class="n">b2</span><span class="p">)</span>
  <span class="n">eAnd</span> <span class="p">(</span><span class="kt">SCopy</span> <span class="n">a1</span> <span class="n">a2</span><span class="p">)</span> <span class="p">(</span><span class="kt">SCopy</span> <span class="n">b1</span> <span class="n">b2</span><span class="p">)</span> <span class="o">=</span> <span class="kt">SCopy</span> <span class="p">(</span><span class="n">eAnd</span> <span class="n">a1</span> <span class="n">b1</span><span class="p">)</span> <span class="p">(</span><span class="n">eAnd</span> <span class="n">a2</span> <span class="n">b2</span><span class="p">)</span>
  <span class="n">eOr</span>  <span class="p">(</span><span class="kt">SCopy</span> <span class="n">a1</span> <span class="n">a2</span><span class="p">)</span> <span class="p">(</span><span class="kt">SCopy</span> <span class="n">b1</span> <span class="n">b2</span><span class="p">)</span> <span class="o">=</span> <span class="kt">SCopy</span> <span class="p">(</span><span class="n">eOr</span>  <span class="n">a1</span> <span class="n">b1</span><span class="p">)</span> <span class="p">(</span><span class="n">eOr</span>  <span class="n">a2</span> <span class="n">b2</span><span class="p">)</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">MulSymantics</span> <span class="n">repr1</span><span class="p">,</span> <span class="kt">MulSymantics</span> <span class="n">repr2</span><span class="p">)</span>
  <span class="o">=&gt;</span> <span class="kt">MulSymantics</span> <span class="p">(</span><span class="kt">SCopy</span> <span class="n">repr1</span> <span class="n">repr2</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">eMul</span> <span class="p">(</span><span class="kt">SCopy</span> <span class="n">a1</span> <span class="n">a2</span><span class="p">)</span> <span class="p">(</span><span class="kt">SCopy</span> <span class="n">b1</span> <span class="n">b2</span><span class="p">)</span> <span class="o">=</span> <span class="kt">SCopy</span> <span class="p">(</span><span class="n">eMul</span> <span class="n">a1</span> <span class="n">b1</span><span class="p">)</span> <span class="p">(</span><span class="n">eMul</span> <span class="n">a2</span> <span class="n">b2</span><span class="p">)</span>
</pre></table></code></div></div><p>As we define new classes of operators on our <code class="language-plaintext highlighter-rouge">Integer</code> and <code class="language-plaintext highlighter-rouge">Bool</code> types, we make <code class="language-plaintext highlighter-rouge">SCopy</code> an instance of them. We can then “thread” the second representation throughout our function calls like so:</p><div class="language-haskell highlighter-rouge"><div class="code-header"> <span text-data=" Haskell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="n">runEval'</span>
  <span class="o">::</span> <span class="n">forall</span> <span class="n">repr</span>
   <span class="o">.</span> <span class="kt">Dynamic</span> <span class="p">(</span><span class="kt">SCopy</span> <span class="kt">Eval</span> <span class="n">repr</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Result</span><span class="p">,</span> <span class="kt">Dynamic</span> <span class="n">repr</span><span class="p">)</span>
<span class="n">runEval'</span> <span class="n">d</span> <span class="o">=</span> <span class="kr">case</span> <span class="n">fromDyn</span> <span class="n">d</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">SCopy</span> <span class="kt">Eval</span> <span class="n">repr</span> <span class="kt">Integer</span><span class="p">)</span> <span class="kr">of</span>
  <span class="kt">Just</span> <span class="p">(</span><span class="kt">SCopy</span> <span class="p">(</span><span class="kt">Eval</span> <span class="n">a</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pure</span> <span class="p">(</span><span class="kt">RInt</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Dynamic</span> <span class="n">pInt</span> <span class="n">r</span><span class="p">)</span>
  <span class="kt">Nothing</span> <span class="o">-&gt;</span> <span class="kr">case</span> <span class="n">fromDyn</span> <span class="n">d</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">SCopy</span> <span class="kt">Eval</span> <span class="n">repr</span> <span class="kt">Bool</span><span class="p">)</span> <span class="kr">of</span>
    <span class="kt">Just</span> <span class="p">(</span><span class="kt">SCopy</span> <span class="p">(</span><span class="kt">Eval</span> <span class="n">a</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pure</span> <span class="p">(</span><span class="kt">RBool</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Dynamic</span> <span class="n">pBool</span> <span class="n">r</span><span class="p">)</span>
    <span class="kt">Nothing</span> <span class="o">-&gt;</span> <span class="kt">Nothing</span>

<span class="n">runPPrint'</span>
  <span class="o">::</span> <span class="n">forall</span> <span class="n">repr</span>
   <span class="o">.</span> <span class="kt">Dynamic</span> <span class="p">(</span><span class="kt">SCopy</span> <span class="kt">PPrint</span> <span class="n">repr</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Text</span><span class="p">,</span> <span class="kt">Dynamic</span> <span class="n">repr</span><span class="p">)</span>
<span class="n">runPPrint'</span> <span class="n">d</span> <span class="o">=</span> <span class="kr">case</span> <span class="n">fromDyn</span> <span class="n">d</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">SCopy</span> <span class="kt">PPrint</span> <span class="n">repr</span> <span class="kt">Text</span><span class="p">)</span> <span class="kr">of</span>
  <span class="kt">Just</span> <span class="p">(</span><span class="kt">SCopy</span> <span class="p">(</span><span class="kt">PPrint</span> <span class="n">a</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pure</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Dynamic</span> <span class="n">pText</span> <span class="n">r</span><span class="p">)</span>
  <span class="kt">Nothing</span> <span class="o">-&gt;</span> <span class="kt">Nothing</span>

<span class="n">runBoth'</span>
  <span class="o">::</span> <span class="n">forall</span> <span class="n">repr</span>
   <span class="o">.</span> <span class="kt">Dynamic</span> <span class="p">(</span><span class="kt">SCopy</span> <span class="kt">Eval</span> <span class="p">(</span><span class="kt">SCopy</span> <span class="kt">PPrint</span> <span class="n">repr</span><span class="p">))</span>
  <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Result</span><span class="p">,</span> <span class="kt">Text</span><span class="p">,</span> <span class="kt">Dynamic</span> <span class="n">repr</span><span class="p">)</span>
<span class="n">runBoth'</span> <span class="n">d</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d'</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">runEval'</span> <span class="n">d</span>
  <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">d''</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">runPPrint'</span> <span class="n">d'</span>
  <span class="n">pure</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">d''</span><span class="p">)</span>
</pre></table></code></div></div><p>Notice each function places a <code class="language-plaintext highlighter-rouge">Dynamic repr</code> of unknown representation in the last position of each return tuple. The caller is then able to interpret this extra <code class="language-plaintext highlighter-rouge">repr</code> as they wish, composing them in arbitrary ways (e.g. <code class="language-plaintext highlighter-rouge">runBoth'</code>).</p><h1 id="limitations">Limitations</h1><p>The expression problem is only partially solved with our <code class="language-plaintext highlighter-rouge">Dynamic</code> strategy. If for instance we wanted to add a new literal type, e.g. a <code class="language-plaintext highlighter-rouge">String</code>, we would unfortunately need to append to the <code class="language-plaintext highlighter-rouge">Typeable</code> and <code class="language-plaintext highlighter-rouge">Dynamic</code> definitions to support them. The standard <code class="language-plaintext highlighter-rouge">dynamics</code> package only allows monomorphic values so in this sense we are stuck. If only needing to add additional functionality to the existing set of types though, we can extend at will.</p><h1 id="conclusion">Conclusion</h1><p>I was initially hoping to extend this post further with a discussion around explicit sharing as noted <a href="https://arxiv.org/pdf/1109.0784.pdf">here</a>, but this post is already getting too long. I covered only a portion of the topics Oleg Kiselyov wrote about, but covered at least the majority of topics I’ve so far been exploring in my own personal projects. I will note that the tagless final approach, while certainly useful, also does add a fair level of cognitive overhead in my experience. Remembering the details around dynamics especially is what prompted me to write this post to begin with.</p><p> </p><hr /><div class="footnotes" role="doc-endnotes"><ol><li id="fn:1" role="doc-endnote"><p>Code here and elsewhere found in the <a href="https://github.com/jrpotter/tagless-final-parsing">tagless-final-parsing</a> repository. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:2" role="doc-endnote"><p>These “additional arguments” are effectively how the tagless final strategy works. The interface is much cleaner though considering all methods are passed around implicity via the <code class="language-plaintext highlighter-rouge">Symantics</code> typeclass. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p></ol></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/programming/'>Programming</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/haskell/" class="post-tag no-text-decoration" >haskell</a> <a href="/tags/functional/" class="post-tag no-text-decoration" >functional</a> <a href="/tags/programming/" class="post-tag no-text-decoration" >programming</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/functional/">functional</a> <a class="post-tag" href="/tags/haskell/">haskell</a> <a class="post-tag" href="/tags/programming/">programming</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/effect-systems/"><div class="card-body"> <span class="timeago small" >Mar 21<i class="unloaded">2022-03-21T00:00:00-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Effect Systems</h3><div class="text-muted small"><p> As I’ve begun exploring the world of so-called algebraic effect systems, I’ve become increasingly frustrated in the level of documentation around them. Learning to use them (and moreso understandin...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <span class="btn btn-outline-primary disabled" prompt="Older"><p>-</p></span> <a href="/posts/effect-systems/" class="btn btn-outline-primary" prompt="Newer"><p>Effect Systems</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/jrpotter">Joshua Potter</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/functional/">functional</a> <a class="post-tag" href="/tags/haskell/">haskell</a> <a class="post-tag" href="/tags/programming/">programming</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
